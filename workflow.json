{
  "name": "My workflow 6",
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "adaptive-instructor",
        "responseMode": "responseNode",
        "options": {}
      },
      "id": "82fa2aec-d1e8-4a2a-8bea-d1ee43796f5d",
      "name": "Main Webhook",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 1.1,
      "position": [
        -4180,
        450
      ],
      "webhookId": "9ef00e80-0d3e-4fcb-b8ff-e621ee6fc02e"
    },
    {
      "parameters": {
        "jsCode": "// CLEAN Session State Manager - ONLY manages state storage\n// No business logic, no routing, no decisions\n\nconst sessionId = $json.sessionId || 'default-session';\nconst action = $json.action || 'start';\nconst learnerInput = $json.learnerInput || {};\n\n// Initialize global state store if needed\nlet globalState = $getWorkflowStaticData('global');\nif (!globalState.sessions) {\n  globalState.sessions = {};\n}\n\n// Initialize new session ONLY if it doesn't exist or action is 'start'\nif (!globalState.sessions[sessionId] || action === 'start') {\n  globalState.sessions[sessionId] = {\n    // Learning state\n    currentConceptIndex: 0,\n    completedConcepts: [],\n    remainingCoreConcepts: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10],\n    insertedConcepts: [],\n    interactionHistory: [],\n    currentConcept: null,\n    lastToolUsed: null,\n    currentConceptTools: [],\n    lastAssessmentScore: null,\n    knowledgeGaps: [],\n    knowledgeStrengths: [],\n    knowledgeEvolution: [],\n    assessmentHistory: [],\n    gapAttempts: {},\n    deferredGaps: [],\n    gapConceptHistory: {},\n    pendingAssessment: null,\n    recentQuestions: [],\n    \n    // State Machine (isolated in global)\n    stateMachine: {\n      currentState: 'uninitialized',\n      previousState: null,\n      stateHistory: [],\n      lastTransition: null\n    },\n    \n    // Metadata\n    createdAt: new Date().toISOString(),\n    lastUpdated: new Date().toISOString()\n  };\n}\n\n// That's it! Just pass through the request data\n// Other nodes will read state directly and make decisions\nreturn {\n  sessionId,\n  action,\n  learnerInput,\n  courseTopic: $json.courseTopic,\n  learnerProfile: $json.learnerProfile,\n  coreConcepts: $json.coreConcepts,\n  userName: $json.userName\n};"
      },
      "id": "55cd7120-00f8-44b6-a02c-fd13f8721c95",
      "name": "Session State Manager",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -3740,
        350
      ]
    },
    {
      "parameters": {
        "jsCode": "// Course Completion Handler\nconst sessionId = $json.sessionId;\nconst session = $json.sessionState;\n\n// Calculate final statistics\nconst totalConcepts = session.completedConcepts.length;\nconst coreConceptsCompleted = session.completedConcepts.filter(id => \n  typeof id === 'number'\n).length;\nconst dynamicConceptsCompleted = totalConcepts - coreConceptsCompleted;\nconst skippedConcepts = session.skippedConcepts?.length || 0;\n\n// Prepare completion response\nconst responseData = {\n  sessionId,\n  toolType: 'course_complete',\n  courseComplete: true,\n  toolData: {\n    title: 'Congratulations! Course Complete',\n    summary: `You've successfully completed all ${totalConcepts} concepts in the course.`,\n    statistics: {\n  coreConceptsCompleted,\n  dynamicConceptsAdded: dynamicConceptsCompleted,\n  conceptsSkipped: skippedConcepts,\n  totalInteractions: session.interactionHistory.length,\n  completionBreakdown: {\n    mastered: Object.values(session.completionMetadata || {})\n      .filter(m => m.completionType === 'mastered').length,\n    adequate: Object.values(session.completionMetadata || {})\n      .filter(m => m.completionType === 'adequate').length,\n    struggled: Object.values(session.completionMetadata || {})\n      .filter(m => m.completionType === 'struggled').length,\n    skipped: skippedConcepts\n  }\n},\n    message: 'Great job completing the AI Native Product Manager course!'\n  },\n  waitingForInput: false\n};\n\nreturn {\n  responseData\n};"
      },
      "id": "f34ad715-9d09-4f81-9597-84d6dacaebc5",
      "name": "Course Completion",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        0,
        0
      ]
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// Fix for Concept Card Handler\n// Location: \"Concept Card Handler\" node\n\nconst concept = $json.currentConcept;\nconst sessionId = $json.sessionId;\nconst learnerNote = $json.learnerInput?.note;\n\n// Get session from global\nconst session = $getWorkflowStaticData('global').sessions[sessionId];\n\n// UPDATE STATE MACHINE\n// This handler only runs when first showing the concept card\nsession.stateMachine.previousState = session.stateMachine.currentState;\nsession.stateMachine.currentState = 'concept_card_shown';\nsession.stateMachine.stateHistory.push({\n  from: session.stateMachine.previousState,\n  to: 'concept_card_shown',\n  action: 'show_concept_card',\n  timestamp: new Date().toISOString(),\n  conceptId: concept.id,\n  conceptTitle: concept.title\n});\n\n// Update concept tools tracking\nif (!session.currentConceptTools.includes('concept_card')) {\n  session.currentConceptTools.push('concept_card');\n}\nsession.lastToolUsed = 'concept_card';\n\n// Save updated state\n$getWorkflowStaticData('global').sessions[sessionId] = session;\n\nconst responseData = {\n  sessionId,\n  toolType: 'concept_card',\n  conceptProgress: {\n    current: session.completedConcepts.length + 1,\n    total: session.remainingCoreConcepts.length + \n           session.completedConcepts.length + \n           session.insertedConcepts.length\n  },\n  toolData: {\n    title: concept.title,\n    summary: concept.summary,\n    expertTips: concept.expertTips,\n    canSubmitNote: true\n  },\n  waitingForInput: true,\n  inputType: 'note',\n  message: 'Read through the concept and feel free to add any notes or questions.'\n};\n\n// Just return the response\nreturn {\n  ...($json),\n  responseData,\n  sessionId,\n  learnerProfile: $json.learnerProfile\n};"
      },
      "id": "27483c7d-6f6c-40ad-ba84-855c211c1799",
      "name": "Concept Card Handler",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -660,
        1075
      ]
    },
    {
      "parameters": {
        "jsCode": "// Fix for Assessment Handler\n// Location: \"Assessment Handler\" node\n\nconst concept = $json.currentConcept;\nconst sessionId = $json.sessionId;\nconst learnerAnswer = $json.learnerInput?.answer;\nconst session = $json.sessionState;\n\n// UPDATE STATE MACHINE\n// This handler runs when showing assessment - always transitions to 'assessment_shown'\nsession.stateMachine.previousState = session.stateMachine.currentState;\nsession.stateMachine.currentState = 'assessment_shown';\nsession.stateMachine.stateHistory.push({\n  from: session.stateMachine.previousState,\n  to: 'assessment_shown',\n  action: 'show_assessment',\n  timestamp: new Date().toISOString(),\n  conceptId: concept.id,\n  conceptTitle: concept.title\n});\n\n// Update session state\nif (!session.currentConceptTools.includes('assessment')) {\n  session.currentConceptTools.push('assessment');\n}\nsession.lastToolUsed = 'assessment';\n\n// Save updated state\n$getWorkflowStaticData('global').sessions[sessionId] = session;\n\nconst responseData = {\n  sessionId,\n  toolType: 'assessment',\n  conceptProgress: {\n    current: session.completedConcepts.length + 1,\n    total: session.remainingCoreConcepts.length + \n           session.completedConcepts.length + \n           session.insertedConcepts.length\n  },\n  toolData: {\n    question: concept.assessmentQuestion,\n    conceptTitle: concept.title\n  },\n  waitingForInput: !learnerAnswer,\n  inputType: 'answer',\n  message: 'Answer the question to check your understanding.'\n};\n\n// If we have an answer, we need to grade it\nif (learnerAnswer) {\n  return {\n    ...($json),\n    needsGrading: true,\n    learnerAnswer,\n    responseData\n  };\n}\n\nreturn {\n  ...($json),\n  needsGrading: false,\n  responseData\n};"
      },
      "id": "fd622193-cb47-4959-992a-0a4f60eb549d",
      "name": "Assessment Handler",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -660,
        1275
      ]
    },
    {
      "parameters": {
        "jsCode": "// Process Combined Grading and Knowledge Analysis\nconst result = JSON.parse($json.choices[0].message.content);\n\n// Get data from the pipeline (from Grade Assessment AI Call)\nconst sessionId = $('Generate Assessment Grading Prompt').first().json.originalData.sessionId;\nconst originalData = $('Generate Assessment Grading Prompt').first().json.originalData;\n\n// Get session directly from global\nconst session = $getWorkflowStaticData('global').sessions[sessionId];\n\n// Update assessment score\nsession.lastAssessmentScore = result.score;\n\n// Update knowledge state from the combined analysis\nif (result.knowledgeUpdate) {\n  session.knowledgeStrengths = result.knowledgeUpdate.updatedStrengths || [];\n  session.knowledgeGaps = result.knowledgeUpdate.updatedGaps || [];\n  \n  // Track knowledge evolution\n  if (!session.knowledgeEvolution) {\n    session.knowledgeEvolution = [];\n  }\n  \n  session.knowledgeEvolution.push({\n    timestamp: new Date().toISOString(),\n    concept: session.currentConcept.title,\n    conceptId: session.currentConcept.id,\n    isDynamic: session.currentConcept.isDynamic || false,\n    score: result.score,\n    strengths: result.knowledgeUpdate.updatedStrengths,\n    gaps: result.knowledgeUpdate.updatedGaps,\n    reasoning: result.knowledgeUpdate.reasoning\n  });\n}\n\n// UPDATE STATE MACHINE\nsession.stateMachine.previousState = session.stateMachine.currentState;\nsession.stateMachine.currentState = 'assessment_graded';\nsession.stateMachine.stateHistory.push({\n  from: 'assessment_submitted',\n  to: 'assessment_graded',\n  action: 'grading_complete',\n  timestamp: new Date().toISOString(),\n  orchestrator: 'core',\n  data: { score: result.score }\n});\n\n// Handle dynamic concept gap resolution\nif (session.currentConcept.isDynamic && result.score >= 3 && session.currentConcept.targetedGaps) {\n  session.knowledgeGaps = session.knowledgeGaps.filter(\n    gap => !session.currentConcept.targetedGaps.includes(gap)\n  );\n}\n\n// Track assessment history\nif (!session.assessmentHistory) {\n  session.assessmentHistory = [];\n}\n\nsession.assessmentHistory.push({\n  concept: session.currentConcept.title,\n  conceptId: session.currentConcept.id,\n  score: result.score,\n  timestamp: new Date().toISOString()\n});\n\n// Save updated state back to global\n$getWorkflowStaticData('global').sessions[sessionId] = session;\n\n// Build the response data structure\nconst responseData = {\n  sessionId,\n  toolType: 'assessment',\n  conceptProgress: {\n    current: session.completedConcepts.length + 1,\n    total: session.remainingCoreConcepts.length + \n           session.completedConcepts.length + \n           session.insertedConcepts.length\n  },\n  toolData: {\n    question: session.currentConcept?.assessmentQuestion,\n    conceptTitle: session.currentConcept?.title,\n    gradingResult: {\n      score: result.score,\n      feedback: result.feedback,\n      understood: result.understood\n    }\n  },\n  waitingForInput: false,\n  nextAction: result.score >= 4 ? \n    'Excellent work! Click Next to continue.' : \n    result.score >= 3 ?\n    'Good understanding! Click Next to continue.' :\n    'Let\\'s reinforce this concept. Click Next to continue.'\n};\n\n// Pass all necessary data forward in the pipeline\nreturn {\n  ...originalData, // Spread the original data\n  gradingResult: result,\n  responseData,\n  sessionId,\n  learnerProfile: originalData.learnerProfile\n};"
      },
      "id": "7c520fab-abee-4681-9a49-a88580d358d1",
      "name": "Process Grading",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1760,
        450
      ]
    },
    {
      "parameters": {
        "jsCode": "// Simple Fix for Prompt Exercise Handler\n// This checks session for any previously generated enhanced task\n\nconst concept = $json.currentConcept;\nconst sessionId = $json.sessionId;\nconst session = $getWorkflowStaticData('global').sessions[sessionId];\n\n// Check multiple sources for enhanced task data\nconst enhancedTask = $json.enhancedPromptTask || \n                    session.currentPromptExercise || \n                    null;\n\n// UPDATE STATE MACHINE\nsession.stateMachine.previousState = session.stateMachine.currentState;\nsession.stateMachine.currentState = 'prompt_exercise_shown';\nsession.stateMachine.stateHistory.push({\n  from: session.stateMachine.previousState,\n  to: 'prompt_exercise_shown',\n  action: 'show_prompt_exercise',\n  timestamp: new Date().toISOString(),\n  conceptId: concept.id,\n  conceptTitle: concept.title\n});\n\n// Update session state\nif (!session.currentConceptTools.includes('prompt_exercise')) {\n  session.currentConceptTools.push('prompt_exercise');\n}\nsession.lastToolUsed = 'prompt_exercise';\n\n// Check if this is the SECOND time showing prompt exercise\n// (after enhancement was generated)\nconst isEnhancedDisplay = session.promptExerciseShowCount > 0;\n\n// Increment show count\nsession.promptExerciseShowCount = (session.promptExerciseShowCount || 0) + 1;\n\n// Save updated state\n$getWorkflowStaticData('global').sessions[sessionId] = session;\n\n// Use enhanced task if available, otherwise show basic\nconst taskToShow = enhancedTask?.task || \n                  (concept.promptTask || 'Generate a prompt for this concept');\n\nconst responseData = {\n  sessionId,\n  toolType: 'prompt_exercise',\n  conceptProgress: {\n    current: session.completedConcepts.length + 1,\n    total: session.remainingCoreConcepts.length + \n           session.completedConcepts.length + \n           session.insertedConcepts.length\n  },\n  toolData: {\n    task: taskToShow,\n    context: enhancedTask?.context || null,\n    hints: enhancedTask?.hints || [],\n    conceptTitle: concept.title,\n    difficulty: enhancedTask?.difficulty || 'intermediate'\n  },\n  waitingForInput: true,\n  inputType: 'prompt',\n  message: 'Practice your prompt engineering skills with this task.'\n};\n\n// Return the response\nreturn {\n  ...($json),\n  responseData,\n  sessionId,\n  learnerProfile: $json.learnerProfile\n};"
      },
      "id": "e40fafb8-4e5b-4924-b2b2-462de100b0bd",
      "name": "Prompt Exercise Handler",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1320,
        1475
      ]
    },
    {
      "parameters": {
        "numberInputs": 3
      },
      "id": "1e2dd109-721d-4b5d-94f5-0009a9878f14",
      "name": "Merge Responses",
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3,
      "position": [
        220,
        200
      ]
    },
    {
      "parameters": {
        "options": {}
      },
      "id": "ee8de2ae-f1cb-4c69-b10f-6fa7a547cec4",
      "name": "Webhook Response",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.1,
      "position": [
        660,
        200
      ]
    },
    {
      "parameters": {
        "path": "reset-session",
        "responseMode": "responseNode",
        "options": {}
      },
      "id": "d0ddb4a0-b456-4dce-a620-e80683cc024f",
      "name": "Reset Session Webhook",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 1.1,
      "position": [
        -4400,
        1735
      ],
      "webhookId": "594653ea-5a3e-4e99-9a1d-c2ecdf0f5c56"
    },
    {
      "parameters": {
        "jsCode": "// Reset Session\nconst sessionId = $json.query?.sessionId || 'default-session';\n\n// Clear session data\nconst sessionState = $getWorkflowStaticData('global');\nif (sessionState.sessions && sessionState.sessions[sessionId]) {\n  delete sessionState.sessions[sessionId];\n}\n\nreturn {\n  success: true,\n  message: `Session ${sessionId} has been reset`,\n  sessionId\n};"
      },
      "id": "a5e752bc-a416-476c-9b27-2d3839e9db70",
      "name": "Reset Session",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -4180,
        1735
      ]
    },
    {
      "parameters": {
        "options": {}
      },
      "id": "a75ecacf-e02a-4116-8789-964a66e0459f",
      "name": "Reset Response",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.1,
      "position": [
        -3960,
        1735
      ]
    },
    {
      "parameters": {
        "jsCode": "// Extract webhook data from the first item in the array\nconst webhookData = $input.first().json.body;\n\n// Add course data\nreturn {\n  sessionId: webhookData.sessionId,\n  userName: webhookData.userName,\n  action: webhookData.action,\n  learnerInput: webhookData.learnerInput,\n  courseTopic: \"How to Become an AI Native Product Manager\",\n  learnerProfile: {\n    role: \"Product Manager\",\n    company: \"TechCorp\",\n    skills: [\"Agile\", \"User Research\", \"Basic Python\"]\n  },\n  \"coreConcepts\": [\n    {\n      \"id\": 1,\n      \"title\": \"Prompt Engineering Essentials\",\n      \"summary\": \"Prompt engineering is the skill of writing clear, structured inputs that guide AI tools to produce high-quality, relevant outputs. It’s not just about asking a question—it’s about communicating with precision, providing context, and defining the role, tone, or format you want. This module helps project managers master this foundational skill so they can make AI tools like ChatGPT work for them across a range of tasks. Good prompting starts by defining the outcome: Are you asking for a summary, a message, a task list, or a risk forecast? Then, you refine the input by adding necessary context—what project, what audience, what constraints. Including tone, format (like bullet points or CSV), and role (e.g., 'you are a project coordinator') helps tailor results. This level of clarity minimizes ambiguity and reduces the need for follow-up corrections. Learners will also explore techniques like using delimiters for structured inputs, applying personas, and iterating based on AI outputs. The goal is to reduce guesswork and enable precise, repeatable results—whether drafting communications, outlining plans, or analyzing decisions. Prompting is a superpower for modern PMs: it lets you turn AI into a strategic assistant. This skill transforms vague requests into clear, actionable outputs that can immediately feed into your project tools and workflows.\",\n      \"expertTips\": [\n        \"Use personas to shift tone and tailor responses.\",\n        \"Split complex tasks into subtasks to avoid token limit issues and improve output quality.\",\n        \"Use triple quotes or backticks to clearly delimit long context or code.\"\n      ],\n      \"assessmentQuestion\": \"What is the most important technique to apply when writing a prompt to ChatGPT for best results?\",\n      \"correctAnswer\": \"Include detailed instructions and context for the task\",\n      \"shouldHavePromptTask\": true\n    },\n        {\n      \"id\": 3,\n      \"title\": \"Project Management AI Foundations\",\n      \"summary\": \"To unlock AI’s full potential as a project manager, you need to understand where and how it integrates into the project lifecycle. AI tools are particularly strong at augmenting core PM activities such as scheduling, forecasting, risk identification, stakeholder communication, and report generation. This module introduces foundational AI use cases across project stages and helps learners map tools to workflows. For example, task decomposition and milestone creation can be accelerated by tools like ChatGPT when paired with a strong prompt. Risk modeling can benefit from AI simulations that explore different 'what-if' scenarios. Communication updates and meeting summaries can be generated more efficiently, freeing PMs to focus on strategy. Learners will gain clarity on the difference between automation (repetitive task execution) and augmentation (strategic insight generation), and how AI supports each. AI foundations also include an understanding of tool categories—chat-based assistants, integrated copilots in platforms like Microsoft Teams or Notion, and no-code AI builders. Once you understand where these tools fit, you can begin evaluating your own workflows for inefficiencies and AI opportunities. This knowledge also helps PMs articulate the ROI of AI to stakeholders—making it easier to champion new tools within the organization.\",\n      \"expertTips\": [\n        \"Ask ChatGPT to ask you questions when you're missing context.\",\n        \"Enable custom instructions for faster, context-aware prompt responses across recurring tasks.\"\n      ],\n      \"assessmentQuestion\": \"Which of the following is the best example of using AI to augment project management activities?\",\n      \"correctAnswer\": \"Using ChatGPT to identify risks in a draft project plan and summarize key concerns\",\n      \"shouldHavePromptTask\": true\n    },\n    {\n      \"id\": 4,\n      \"title\": \"Smarter Planning with AI\",\n      \"summary\": \"AI excels at turning goals into structured plans—when guided correctly. In this module, learners will explore how to use AI to generate project roadmaps, create task hierarchies, define dependencies, and sequence milestones. Planning with AI begins by inputting a clear objective or deliverable and adding constraints like deadlines, resources, or blockers. The AI can then propose a draft plan, which the project manager reviews and refines. The real power lies in iteration—adjusting prompts to tweak scope, task order, or effort level. AI also supports reverse planning, where you start from a fixed deadline and ask it to work backwards. Project managers will also learn how to test and validate AI-generated plans: Does the dependency order make sense? Are key milestones too dense or too sparse? Is effort distribution realistic? Learners will practice identifying flaws and giving corrective instructions, reinforcing that AI is a collaborator, not a replacement. The module encourages hands-on testing with tools like ChatGPT or Copilot embedded in planning tools. Learners who complete this module will be able to use AI to jumpstart planning sessions, unblock ambiguity, and refine their timelines with greater speed and clarity.\",\n      \"expertTips\": [],\n      \"assessmentQuestion\": \"When reviewing an AI-generated project plan, what is a good follow-up action?\",\n      \"correctAnswer\": \"Check for inaccurate task dependencies and revise the prompt to fix the logic\",\n      \"shouldHavePromptTask\": true\n    }\n  ]\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -3960,
        350
      ],
      "id": "df42b48a-2021-4f7a-8827-0249d1e0235e",
      "name": "Init Course Data"
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// Extract Response Data\nconst responseData = $json.responseData;\n\nif (!responseData) {\n  throw new Error('No responseData found in input');\n}\n\nreturn responseData;"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        440,
        200
      ],
      "id": "25182af9-756c-4c78-888b-36a27e3f204b",
      "name": "Limit Data"
    },
    {
      "parameters": {},
      "type": "n8n-nodes-base.manualTrigger",
      "typeVersion": 1,
      "position": [
        -4400,
        250
      ],
      "id": "61f5746a-5abd-491b-9cec-a587aea2e542",
      "name": "When clicking 'Test workflow'"
    },
    {
      "parameters": {
        "mode": "raw",
        "jsonOutput": "{\n  \"body\": {\n    \"sessionId\": \"manual_session\",\n    \"userName\": \"Mohammed Ali\",\n    \"action\": \"next\",\n    \"learnerInput\": {}\n  }\n}",
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        -4180,
        250
      ],
      "id": "90ddc41c-c900-4a6c-acfd-5111927cb4a0",
      "name": "Edit Fields"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://api.openai.com/v1/chat/completions",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "openAiApi",
        "sendBody": true,
        "bodyParameters": {
          "parameters": [
            {
              "name": "model",
              "value": "={{ $json.model }}"
            },
            {
              "name": "messages",
              "value": "={{ $json.messages }}"
            },
            {
              "name": "temperature",
              "value": "={{ $json.temperature }}"
            },
            {
              "name": "max_tokens",
              "value": "={{ $json.max_tokens }}"
            },
            {
              "name": "response_format",
              "value": "={{ $json.response_format }}"
            }
          ]
        },
        "options": {}
      },
      "id": "5de5ab8c-6219-4fbf-9403-d33d7f129892",
      "name": "Grade Assessment AI Call",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -1980,
        450
      ],
      "credentials": {
        "openAiApi": {
          "id": "UFaW72U0IV5U0Ec5",
          "name": "OpenAi account"
        }
      }
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// Generate Concept Prompt - Prepares prompt for creating new adaptive concepts\nconst messages = [\n  {\n    role: \"system\",\n    content: \"Generate a new mini-concept to address a specific learning gap. The concept MUST directly target the identified gap, and the assessment question MUST verify the learner understands the gap area. Focus on building a bridge from their current understanding to the correct concept.\"\n  },\n  {\n    role: \"user\", \n    content: `Context:\n- Main Topic: ${$json.courseTopic}\n- Current Concept: ${$json.currentConcept.title}\n- Knowledge Gap: ${$json.orchestratorDecision.conceptNeeded.reason}\n- Specific Gap to Address: ${$json.sessionState.knowledgeGaps?.[0] || $json.orchestratorDecision.conceptNeeded.focus}\n- Learner Profile: ${$json.learnerProfile.role} at ${$json.learnerProfile.company}\n\nThe learner scored ${$json.sessionState.lastAssessmentScore}/5 and showed confusion about: \"${$json.sessionState.knowledgeGaps?.[0] || 'the core concept'}\"\n\nCreate a focused concept that DIRECTLY addresses this specific gap: \"${$json.orchestratorDecision.conceptNeeded.reason}\"\n\nThe assessment question MUST test whether the learner understands: ${$json.sessionState.knowledgeGaps?.[0] || $json.orchestratorDecision.conceptNeeded.focus}\n\nReturn JSON:\n{\n  \"title\": \"Clear, specific title\",\n  \"summary\": \"500 word overview\",\n  \"expertTips\": [\"2-3 practical tips\"],\n  \"assessmentQuestion\": \"Targeted question to verify understanding\",\n  \"correctAnswer\": \"Brief correct answer\"\n}`\n  }\n];\n\nreturn {\n  messages,\n  model: \"gpt-4o\",\n  temperature: 0.7,\n  max_tokens: 1000,\n  response_format: { type: \"json_object\" },\n  // Pass through ALL the original data\n  originalData: $json\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -2200,
        1371
      ],
      "id": "abc01a79-77ff-4423-aabf-aa22ba20978b",
      "name": "Generate New Concept Prompt"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://api.openai.com/v1/chat/completions",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "openAiApi",
        "sendBody": true,
        "bodyParameters": {
          "parameters": [
            {
              "name": "model",
              "value": "={{ $json.model }}"
            },
            {
              "name": "messages",
              "value": "={{ $json.messages }}"
            },
            {
              "name": "temperature",
              "value": "={{ $json.temperature }}"
            },
            {
              "name": "max_tokens",
              "value": "={{ $json.max_tokens }}"
            },
            {
              "name": "response_format",
              "value": "={{ $json.response_format }}"
            }
          ]
        },
        "options": {}
      },
      "id": "f785b415-d1f4-423f-a029-6b08717b2608",
      "name": "Generate New Concept AI Call",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -1980,
        1371
      ],
      "credentials": {
        "openAiApi": {
          "id": "UFaW72U0IV5U0Ec5",
          "name": "OpenAi account"
        }
      }
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// Combined Routing & Core Orchestrator - FIXED\n// Handles both routing decisions AND simple deterministic transitions\n\nconst sessionId = $json.sessionId;\nconst action = $json.action;\nconst learnerInput = $json.learnerInput;\n\n// Read state directly from global\nconst session = $getWorkflowStaticData('global').sessions[sessionId];\nif (!session) {\n  throw new Error(`Session ${sessionId} not found`);\n}\n\n// Get current state\nconst currentState = session.stateMachine.currentState;\nconst lastToolUsed = session.lastToolUsed;\nconst pendingGrading = currentState === 'assessment_submitted';\nconst currentConcept = session.currentConcept;\n\n// Check if course is complete\nconst allConceptsCompleted = session.remainingCoreConcepts.length === 0;\nconst noPendingDynamicConcepts = session.insertedConcepts.every(\n  conceptId => session.completedConcepts.includes(conceptId)\n);\nconst courseComplete = !currentConcept && allConceptsCompleted && noPendingDynamicConcepts;\n\nconsole.log(`Routing: action=${action}, state=${currentState}, currentConcept=${currentConcept?.title}, remaining=${session.remainingCoreConcepts.length}`);\n\n// Initialize routing variables\nlet routeTo = null;\nlet updateState = null;\n\n// ROUTING LOGIC - Determine routing\nif (courseComplete) {\n  routeTo = 'show_completion';\n  updateState = 'course_complete';\n}\n// Start of course\nelse if (action === 'start' && currentState === 'uninitialized') {\n  routeTo = 'show_welcome';\n  updateState = 'welcome';\n}\n// Moving from welcome to first concept\nelse if (action === 'next' && currentState === 'welcome') {\n  // Get the first concept and set it as current\n  let nextConcept = null;\n  if (session.remainingCoreConcepts.length > 0) {\n    const nextId = session.remainingCoreConcepts[0];\n    nextConcept = $json.coreConcepts.find(c => c.id === nextId);\n    \n    if (nextConcept) {\n      // IMPORTANT: Remove from remaining WHEN WE START IT\n      session.remainingCoreConcepts = session.remainingCoreConcepts.filter(id => id !== nextId);\n      \n      // Mark it as core concept\n      nextConcept.isCore = true;\n      \n      // Set as current\n      session.currentConcept = nextConcept;\n      session.currentConceptTools = [];\n      session.lastAssessmentScore = null;\n      \n      // Route to Adaptive Orchestrator\n      routeTo = 'adaptive_orchestrator';\n    }\n  }\n}\n// After concept completion, get next concept\nelse if (action === 'next' && currentState === 'concept_completing') {\n  // First check for any inserted dynamic concepts that haven't been completed\n  const pendingDynamicConcepts = session.insertedConcepts.filter(\n    id => !session.completedConcepts.includes(id)\n  );\n  \n  let nextConcept = null;\n  \n  if (pendingDynamicConcepts.length > 0) {\n    // We have a dynamic concept to show\n    // For now, just create a placeholder - in real implementation, \n    // you'd retrieve the stored dynamic concept\n    const dynamicId = pendingDynamicConcepts[0];\n    console.log(`Loading dynamic concept: ${dynamicId}`);\n    \n    // Remove from insertedConcepts since we're starting it\n    session.insertedConcepts = session.insertedConcepts.filter(id => id !== dynamicId);\n    \n    // In a real implementation, you'd load the dynamic concept from storage\n    // For now, we'll skip to the next core concept\n    // TODO: Implement dynamic concept storage and retrieval\n  }\n  \n  // Get next core concept if no dynamic concepts pending\n  if (!nextConcept && session.remainingCoreConcepts.length > 0) {\n    const nextId = session.remainingCoreConcepts[0];\n    nextConcept = $json.coreConcepts.find(c => c.id === nextId);\n    \n    if (nextConcept) {\n      // Remove from remaining\n      session.remainingCoreConcepts = session.remainingCoreConcepts.filter(id => id !== nextId);\n      \n      // Mark it as core concept\n      nextConcept.isCore = true;\n      \n      // Set as current\n      session.currentConcept = nextConcept;\n      session.currentConceptTools = [];\n      session.lastAssessmentScore = null;\n      session.knowledgeGaps = [];\n      \n      routeTo = 'adaptive_orchestrator';\n      updateState = 'concept_started';\n    }\n  } else if (!nextConcept) {\n    // No more concepts - course complete\n    routeTo = 'show_completion';\n    updateState = 'course_complete';\n  }\n}\n// Assessment submission\nelse if (action === 'submit_response' && lastToolUsed === 'assessment' && learnerInput?.answer) {\n  // Record the interaction\n  session.interactionHistory.push({\n    concept: session.currentConcept?.title,\n    tool: 'assessment',\n    input: learnerInput,\n    timestamp: new Date().toISOString()\n  });\n  \n  // If there's a note, let Adaptive Orchestrator decide whether to grade\n  if (learnerInput?.note) {\n    session.pendingAssessment = {\n      answer: learnerInput.answer,\n      note: learnerInput.note,\n      question: session.currentConcept?.assessmentQuestion\n    };\n    routeTo = 'adaptive_orchestrator';\n    updateState = 'assessment_with_note_pending';\n  } else {\n    // No note - proceed with normal grading\n    routeTo = 'grade_assessment';\n    updateState = 'assessment_submitted';\n  }\n}\n// Concept card note submission\nelse if (action === 'submit_response' && lastToolUsed === 'concept_card') {\n  // Record the interaction\n  session.interactionHistory.push({\n    concept: session.currentConcept?.title,\n    tool: 'concept_card',\n    input: learnerInput,\n    timestamp: new Date().toISOString()\n  });\n  \n  if (learnerInput?.note) {\n    session.recentQuestions.push(learnerInput.note);\n    if (session.recentQuestions.length > 5) {\n      session.recentQuestions.shift();\n    }\n  }\n  \n  routeTo = 'adaptive_orchestrator';\n  updateState = 'concept_note_submitted';\n}\n// Prompt exercise submission WITHOUT note - direct to evaluation\nelse if (action === 'submit_response' && lastToolUsed === 'prompt_exercise' && learnerInput?.prompt && !learnerInput?.note) {\n  // Record the interaction\n  session.interactionHistory.push({\n    concept: session.currentConcept?.title,\n    tool: 'prompt_exercise',\n    input: learnerInput,\n    timestamp: new Date().toISOString()\n  });\n  \n  // Store prompt for evaluation\n  session.pendingPromptEvaluation = {\n    prompt: learnerInput.prompt,\n    task: session.currentPromptExercise?.generatedTask || session.currentConcept?.promptTask,\n    evaluationCriteria: session.currentPromptExercise?.evaluationCriteria\n  };\n  \n  routeTo = 'evaluate_prompt';\n  updateState = 'prompt_submitted';\n}\n// Prompt exercise submission WITH note - let Adaptive Orchestrator decide\nelse if (action === 'submit_response' && lastToolUsed === 'prompt_exercise' && learnerInput?.prompt && learnerInput?.note) {\n  // Record the interaction\n  session.interactionHistory.push({\n    concept: session.currentConcept?.title,\n    tool: 'prompt_exercise',\n    input: learnerInput,\n    timestamp: new Date().toISOString()\n  });\n  \n  // Store prompt for potential evaluation\n  session.pendingPromptEvaluation = {\n    prompt: learnerInput.prompt,\n    note: learnerInput.note,\n    task: session.currentPromptExercise?.generatedTask || session.currentConcept?.promptTask,\n    evaluationCriteria: session.currentPromptExercise?.evaluationCriteria\n  };\n  \n  // Let Adaptive Orchestrator decide based on the note\n  routeTo = 'adaptive_orchestrator';\n  updateState = 'prompt_with_note_submitted';\n}\n// Post-grading decision needed\nelse if (session.stateMachine.currentState === 'assessment_graded') {\n  // Assessment was just graded, decide next action\n  routeTo = 'adaptive_orchestrator';\n}\n// General next action after completing a concept\nelse if (action === 'next' && currentState === 'concept_completing') {\n  // This is handled above in the specific case\n  console.log('Concept completing state - should have been handled above');\n}\n// General next action\nelse if (action === 'next' && currentConcept) {\n  routeTo = 'adaptive_orchestrator';\n}\n\n// Update state machine if needed\nif (updateState) {\n  session.stateMachine.previousState = currentState;\n  session.stateMachine.currentState = updateState;\n  session.stateMachine.stateHistory.push({\n    from: currentState,\n    to: updateState,\n    action: action,\n    timestamp: new Date().toISOString(),\n    orchestrator: 'core'\n  });\n}\n\n// Save back to global\n$getWorkflowStaticData('global').sessions[sessionId] = session;\n\n// Pass through current concept if it exists\nconst outputData = {\n  sessionId,\n  action,\n  learnerInput,\n  courseTopic: $json.courseTopic,\n  learnerProfile: $json.learnerProfile,\n  coreConcepts: $json.coreConcepts,\n  userName: $json.userName,\n  routeTo: routeTo,\n  courseComplete: courseComplete\n};\n\n// IMPORTANT: Include currentConcept if we have one\nif (session.currentConcept) {\n  outputData.currentConcept = session.currentConcept;\n}\n\n// Include session state for debugging\noutputData.sessionState = {\n  remainingCoreConcepts: session.remainingCoreConcepts,\n  completedConcepts: session.completedConcepts,\n  currentConceptId: session.currentConcept?.id,\n  stateMachine: session.stateMachine\n};\n\n// SINGLE RETURN FORMAT\nreturn outputData;"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -3520,
        350
      ],
      "id": "477e2a63-2c99-4408-8d8e-1c0ad2757ce9",
      "name": "Core Orchestrator"
    },
    {
      "parameters": {
        "rules": {
          "values": [
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "id": "51295a96-00b1-497c-8a67-dd809c86da1b",
                    "leftValue": "{{ $json.routeTo }}",
                    "rightValue": "show_completion",
                    "operator": {
                      "type": "string",
                      "operation": "equals",
                      "name": "filter.operator.equals"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "courseComplete"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "leftValue": "={{ $json.routeTo }}",
                    "rightValue": "show_welcome",
                    "operator": {
                      "type": "string",
                      "operation": "equals"
                    },
                    "id": "8691f62e-4d5e-43ff-9a26-5d7b4c81ee13"
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "welcome"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "id": "c07fc040-2d20-447e-b1df-286099b45a6a",
                    "leftValue": "={{ $json.routeTo }}",
                    "rightValue": "grade_assessment",
                    "operator": {
                      "type": "string",
                      "operation": "equals",
                      "name": "filter.operator.equals"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "gradeAssessment"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "id": "2c2549a8-034c-4335-8948-55e84333d21e",
                    "leftValue": "={{ $json.routeTo }}",
                    "rightValue": "evaluate_prompt",
                    "operator": {
                      "type": "string",
                      "operation": "equals",
                      "name": "filter.operator.equals"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "evaluatePrompt"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "id": "4b5e3875-e16a-4855-9817-960a1cce95ab",
                    "leftValue": "={{ $json.routeTo }}",
                    "rightValue": "adaptive_orchestrator",
                    "operator": {
                      "type": "string",
                      "operation": "equals",
                      "name": "filter.operator.equals"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "toAdaptiveOrchestrator"
            }
          ]
        },
        "options": {
          "fallbackOutput": "extra",
          "renameFallbackOutput": "adaptive_orchestrator"
        }
      },
      "type": "n8n-nodes-base.switch",
      "typeVersion": 3.2,
      "position": [
        -3300,
        287
      ],
      "id": "a1fd4fa2-82cf-4dc8-8c4a-8dec214ecd9a",
      "name": "Core Router"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://api.openai.com/v1/chat/completions",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "openAiApi",
        "sendBody": true,
        "bodyParameters": {
          "parameters": [
            {
              "name": "model",
              "value": "={{ $json.model }}"
            },
            {
              "name": "messages",
              "value": "={{ $json.messages }}"
            },
            {
              "name": "temperature",
              "value": "={{ $json.temperature }}"
            },
            {
              "name": "max_tokens",
              "value": "={{ $json.max_tokens }}"
            },
            {
              "name": "response_format",
              "value": "={{ $json.response_format }}"
            }
          ]
        },
        "options": {}
      },
      "id": "3b731548-34c9-471b-96cb-28c554573d60",
      "name": "Adaptive Orchestrator AI Call",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -2860,
        875
      ],
      "credentials": {
        "openAiApi": {
          "id": "UFaW72U0IV5U0Ec5",
          "name": "OpenAi account"
        }
      }
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// Process Adaptive Orchestrator Decision - ENHANCED WITH PROMPT EXERCISE CHECK\nconst orchestratorDecision = JSON.parse($json.choices[0].message.content);\n\nconst sessionId = $('Generate Adaptive Orchestrator Router Prompt').first().json.originalData.sessionId;\nconst originalData = $('Generate Adaptive Orchestrator Router Prompt').first().json.originalData;\n\n// Get session directly from global\nconst session = $getWorkflowStaticData('global').sessions[sessionId];\n\n// Initialize tracking if needed\nif (!session.gapAttempts) session.gapAttempts = {};\nif (!session.deferredGaps) session.deferredGaps = [];\nif (!session.skippedConcepts) session.skippedConcepts = [];\n\n// PROMPT EXERCISE SAFETY CHECK\nif (orchestratorDecision.nextAction === 'prompt_exercise') {\n  const shouldHavePromptTask = !!session.currentConcept?.shouldHavePromptTask;\n  \n  if (!shouldHavePromptTask) {\n    // Override the decision - no prompt task defined for this concept\n    console.log(`Overriding prompt_exercise decision - no shouldHavePromptTask defined for: ${session.currentConcept?.title}`);\n    \n    // Determine better fallback based on what tools have been used\n    if (!session.currentConceptTools.includes('assessment')) {\n      // Haven't done assessment yet - go there\n      orchestratorDecision.nextAction = 'assessment';\n      orchestratorDecision.reasoning = `No prompt task defined. Proceeding to assessment.`;\n    } else if (session.lastAssessmentScore && session.lastAssessmentScore < 3) {\n      // Assessment done but score was low - consider remediation\n      orchestratorDecision.nextAction = 'insert_concept';\n      orchestratorDecision.reasoning = `No prompt task defined. Low assessment score suggests remediation needed.`;\n      orchestratorDecision.conceptNeeded = {\n        reason: \"Reinforce understanding based on low assessment score\",\n        focus: session.knowledgeGaps[0] || \"Core concept understanding\"\n      };\n    } else {\n      // Assessment done with decent score - safe to complete\n      orchestratorDecision.nextAction = 'concept_complete';\n      orchestratorDecision.reasoning = `No prompt task defined. Assessment completed successfully.`;\n    }\n  }\n}\n\n// HANDLE SKIP GRADING SIGNAL\nif (orchestratorDecision.skipGrading && session.pendingAssessment) {\n \n  // UPDATE STATE MACHINE - Track skipped assessment\n  session.stateMachine.previousState = session.stateMachine.currentState;\n  session.stateMachine.currentState = 'assessment_skipped';\n  session.stateMachine.stateHistory.push({\n    from: session.stateMachine.previousState,\n    to: 'assessment_skipped',\n    action: 'skip_assessment_grading',\n    timestamp: new Date().toISOString(),\n    skipReason: orchestratorDecision.skipReason || 'Based on learner note',\n    conceptId: session.currentConcept?.id\n  });\n  \n  // Track that assessment was skipped\n  if (!session.assessmentHistory) session.assessmentHistory = [];\n  session.assessmentHistory.push({\n    concept: session.currentConcept.title,\n    conceptId: session.currentConcept.id,\n    answer: session.pendingAssessment.answer,\n    note: session.pendingAssessment.note,\n    score: null,\n    skipped: true,\n    skipReason: orchestratorDecision.skipReason || 'Based on learner note',\n    timestamp: new Date().toISOString()\n  });\n  \n  // Clear pending assessment\n  session.pendingAssessment = null;\n}\n\n// HANDLE SKIP EVALUATION SIGNAL (for prompt exercises)\nif (orchestratorDecision.skipEvaluation && session.pendingPromptEvaluation) {\n  // UPDATE STATE MACHINE - Track skipped prompt evaluation\n  session.stateMachine.previousState = session.stateMachine.currentState;\n  session.stateMachine.currentState = 'prompt_evaluation_skipped';\n  session.stateMachine.stateHistory.push({\n    from: session.stateMachine.previousState,\n    to: 'prompt_evaluation_skipped',\n    action: 'skip_prompt_evaluation',\n    timestamp: new Date().toISOString(),\n    skipReason: orchestratorDecision.skipReason || 'Based on learner note',\n    conceptId: session.currentConcept?.id\n  });\n  \n  // Clear pending evaluation state\n  if (!session.promptHistory) session.promptHistory = [];\n  session.promptHistory.push({\n    concept: session.currentConcept.title,\n    conceptId: session.currentConcept.id,\n    prompt: session.pendingPromptEvaluation.prompt,\n    note: session.pendingPromptEvaluation.note,\n    task: session.pendingPromptEvaluation.task,\n    score: null,\n    skipped: true,\n    skipReason: orchestratorDecision.skipReason || 'Based on learner note',\n    timestamp: new Date().toISOString()\n  });\n  \n  // Clear pending evaluation\n  session.pendingPromptEvaluation = null;\n  \n  // Also clear the current prompt exercise since we're skipping\n  session.currentPromptExercise = null;\n}\n\n// HANDLE MARK AS COMPLETE SIGNAL (for skipping concepts)\nif (orchestratorDecision.markAsComplete && orchestratorDecision.completionType === 'skipped') {\n  // UPDATE STATE MACHINE - Track concept skip\n  session.stateMachine.previousState = session.stateMachine.currentState;\n  session.stateMachine.currentState = 'concept_skipped';\n  session.stateMachine.stateHistory.push({\n    from: session.stateMachine.previousState,\n    to: 'concept_skipped',\n    action: 'skip_concept',\n    timestamp: new Date().toISOString(),\n    skipReason: orchestratorDecision.skipReason || 'Learner requested skip',\n    conceptId: session.currentConcept?.id,\n    conceptTitle: session.currentConcept?.title,\n    toolsCompleted: session.currentConceptTools\n  });\n  \n  // Track as skipped concept\n  session.skippedConcepts.push({\n    conceptId: session.currentConcept.id,\n    conceptTitle: session.currentConcept.title,\n    reason: orchestratorDecision.skipReason || 'Learner requested skip',\n    toolsCompleted: session.currentConceptTools,\n    hadPendingAssessment: !!session.pendingAssessment,\n    hadPendingPromptEvaluation: !!session.pendingPromptEvaluation,\n    timestamp: new Date().toISOString()\n  });\n  \n  // Clear any pending assessment/evaluation data\n  session.pendingAssessment = null;\n  session.pendingPromptEvaluation = null;\n  session.lastAssessmentScore = null;\n  \n  // Override action to concept_complete to move forward\n  orchestratorDecision.nextAction = 'concept_complete';\n}\n\n// EXISTING GAP ATTEMPT LOGIC\n// Check if we're trying to insert a concept for a gap we've already attempted multiple times\nif (orchestratorDecision.nextAction === 'insert_concept' && session.knowledgeGaps.length > 0) {\n  const targetGap = session.knowledgeGaps[0];\n  const attempts = session.gapAttempts[targetGap] || 0;\n  \n  if (attempts >= 2) {\n    // Override the orchestrator's decision\n    orchestratorDecision.nextAction = 'concept_complete';\n    orchestratorDecision.reasoning = `Gap \"${targetGap}\" has been attempted ${attempts} times. Moving forward with core curriculum.`;\n    \n    // Move gap to deferred list\n    session.knowledgeGaps = session.knowledgeGaps.filter(gap => gap !== targetGap);\n    session.deferredGaps.push({\n      gap: targetGap,\n      attempts: attempts,\n      deferredAt: new Date().toISOString()\n    });\n  }\n}\n\n// Store orchestrator decision for reference\nsession.lastOrchestratorDecision = {\n  decision: orchestratorDecision,\n  timestamp: new Date().toISOString()\n};\n\n// Store exercise focus if provided\nif (orchestratorDecision.exerciseFocus) {\n  session.currentExerciseFocus = orchestratorDecision.exerciseFocus;\n}\n\n// Save updated state back to global\n$getWorkflowStaticData('global').sessions[sessionId] = session;\n\n// Pass forward with the orchestrator decision\nreturn {\n  ...originalData,\n  orchestratorDecision,\n  sessionState: session,\n  nextAction: orchestratorDecision.nextAction\n};"
      },
      "id": "75db542b-2dce-4139-9fad-19b935569ef1",
      "name": "Process Adaptive Orchestrator Decision",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -2640,
        875
      ]
    },
    {
      "parameters": {
        "jsCode": "// Smart Reply Generator for 6 Input Handlers\nconst toolType = $json.responseData?.toolType;\nconst toolData = $json.responseData?.toolData;\nconst sessionId = $json.sessionId;\n\n// Get session for context\nconst session = $getWorkflowStaticData('global').sessions[sessionId];\n\n// Determine which handler sent this based on context\nlet inputSource = '';\nif ($json.needsGrading && toolType === 'assessment') {\n  inputSource = 'assessment_handler';\n} else if ($json.gradingResult && toolType === 'assessment') {\n  inputSource = 'process_grading';\n} else if ($json.evaluationResult && toolType === 'prompt_exercise') {\n  inputSource = 'process_prompt_evaluation';\n} else if ($json.enhancedPromptTask && toolType === 'prompt_exercise') {\n  inputSource = 'process_generated_prompt';\n} else if (toolType === 'concept_card') {\n  inputSource = 'concept_card_handler';\n} else if (toolType === 'transition') {\n  inputSource = 'complete_concept_handler';\n}\n\n// Build context for smart reply generation\nlet contextPrompt = '';\n\nswitch(inputSource) {\n  case 'concept_card_handler':\n    // Input 1: Concept Card Handler - showing concept for first time\n    contextPrompt = `Tool: Concept Card (Initial Display)\nCurrent Concept: ${toolData.title}\nSummary: ${toolData.summary}\nLearner Role: ${$json.learnerProfile?.role || 'Product Manager'}\nStatus: Learner is reading this concept and can add notes\n\nGenerate 5 smart reply options for notes they might want to add:\n- Question about applying this to their role\n- Request for concrete examples\n- Express confusion about specific aspect\n- Indicate they already know this\n- Ask how this relates to previous concepts`;\n    break;\n  case 'assessment_handler':\n    // Input 2: Assessment Handler - just submitted answer, waiting for grading\n    contextPrompt = `Tool: Assessment (Answer Submitted, Pre-Grading)\nQuestion: ${toolData.question}\nConcept: ${toolData.conceptTitle}\nLearner Role: ${$json.learnerProfile?.role || 'Product Manager'}\nStatus: Answer submitted, can add a note before grading\n\nGenerate 5 smart reply options for notes about their answer:\n- Admit uncertainty or guessing\n- Challenge the question wording\n- Explain their reasoning\n- Point out ambiguity in options\n- Request hint or clarification`;\n    break;\n    \n  case 'process_grading':\n    // Input 3: Process Grading - seeing their score and feedback\n    const score = toolData.gradingResult?.score || 0;\n    contextPrompt = `Tool: Assessment Results (Post-Grading)\nQuestion: ${toolData.question}\nScore: ${score}/5\nFeedback: ${toolData.gradingResult?.feedback}\nLearner Role: ${$json.learnerProfile?.role || 'Product Manager'}\nStatus: Viewing grading results\n\nGenerate 5 smart reply options based on score ${score}/5:\n${score >= 4 ? \n'- Express satisfaction\\n- Ask for advanced application\\n- Ready for harder challenges\\n- Connect to their work context\\n- Move to next concept' : \nscore >= 2 ? \n'- Ask for clarification\\n- Request another example\\n- Partial understanding acknowledgment\\n- Disagree with grading\\n- Need more practice' : \n'- Express frustration\\n- Request detailed explanation\\n- Ask for simpler version\\n- Need to review concept\\n- Want personal help'}`;\n    break;\n    \n  case 'process_prompt_evaluation':\n    // Input 4: Process Prompt Evaluation - seeing evaluation results\n    const promptScore = toolData.evaluationResult?.score || 0;\n    contextPrompt = `Tool: Prompt Exercise Results (Post-Evaluation)\nTask: ${toolData.task}\nScore: ${promptScore}/5\nFeedback: ${toolData.evaluationResult?.feedback}\nAI Response: ${toolData.evaluationResult?.simulatedAIResponse ? 'Shown' : 'Not shown'}\nLearner Role: ${$json.learnerProfile?.role || 'Product Manager'}\nStatus: Viewing prompt evaluation\n\nGenerate 5 smart reply options for score ${promptScore}/5:\n- ${promptScore >= 4 ? 'Want more advanced prompting' : 'Need better examples'}\n- ${promptScore >= 4 ? 'Try industry-specific prompt' : 'Request prompt templates'}\n- ${promptScore >= 3 ? 'Understand the feedback' : 'Confused by evaluation'}\n- Ask about best practices\n- ${promptScore < 3 ? 'Want to retry' : 'Ready to continue'}`;\n    break;\n    \n  case 'process_generated_prompt':\n    // Input 5: Process Generated Prompt Exercise - seeing the enhanced exercise\n    const difficulty = toolData.difficulty || 'unknown';\n    contextPrompt = `Tool: Prompt Exercise (Enhanced Task Display)\nTask: ${toolData.task}\nContext: ${toolData.context || 'None'}\nHints Available: ${toolData.hints?.length || 0}\nDifficulty: ${difficulty}\nLearner Role: ${$json.learnerProfile?.role || 'Product Manager'}\nStatus: Viewing prompt exercise task\n\nGenerate 5 smart reply options for task difficulty \"${difficulty}\":\n- ${difficulty === 'advanced' ? 'This looks challenging' : 'I can handle this'}\n- ${toolData.hints?.length ? 'Show me a hint' : 'Need more context'}\n- Ask about evaluation criteria\n- ${difficulty === 'beginner' ? 'Too easy for me' : 'Request simpler version'}\n- Connect to their ${$json.learnerProfile?.role} role`;\n    break;\n    \n  case 'complete_concept_handler':\n    // Input 6: Complete Concept - transitioning between concepts\n    const completedTitle = toolData.completedConcept || session.currentConcept?.title;\n    const wasSkipped = session.skippedConcepts?.some(\n      skip => skip.conceptTitle === completedTitle\n    );\n    const lastScore = session.lastAssessmentScore;\n    \n    contextPrompt = `Tool: Concept Transition\nJust Completed: ${completedTitle}\nCompletion Type: ${wasSkipped ? 'Skipped' : lastScore >= 4 ? 'Mastered' : lastScore >= 3 ? 'Adequate' : 'Struggled'}\nAssessment Score: ${lastScore || 'N/A'}/5\nProgress: ${session.completedConcepts?.length || 0} concepts done\nStatus: Moving to next concept\n\nGenerate 5 smart reply options for this transition:\n${wasSkipped ? \n'- Why I skipped this\\n- Actually, let me try it\\n- I already know this well\\n- Move to next topic\\n- Will this hurt my progress?' :\nlastScore < 3 ? \n'- Wait, I need review\\n- Still confused about X\\n- Can we go slower?\\n- Show me similar concept\\n- I need a break' :\n'- Great, what\\'s next?\\n- How does this connect?\\n- That was helpful\\n- Ready for harder stuff\\n- Can I reference this later?'}`;\n    break;\n    \n  default:\n    // Fallback - should not happen with proper routing\n    contextPrompt = `Tool: Unknown Input Source\nCurrent State: ${session.stateMachine?.currentState}\nTool Type: ${toolType}\nLearner Role: ${$json.learnerProfile?.role || 'Product Manager'}\n\nGenerate 5 general smart reply options for learning.`;\n}\n\n// Add session context to all prompts\nconst additionalContext = `\n\nAdditional Context:\n- Knowledge Gaps: ${session.knowledgeGaps?.join(', ') || 'None identified'}\n- Knowledge Strengths: ${session.knowledgeStrengths?.join(', ') || 'None identified'}\n- Recent Questions: ${session.recentQuestions?.slice(-2).join('; ') || 'None'}\n- Learning Progress: ${session.completedConcepts?.length || 0} concepts completed\n- Current State: ${session.stateMachine?.currentState}\n- Last Tool Used: ${session.lastToolUsed}`;\n\nconst messages = [\n  {\n    role: \"system\",\n    content: \"You are an adaptive learning assistant generating smart reply options for learners. Create short, natural responses that a learner might click instead of typing. Each reply should be under 10 words and feel conversational. Make them contextually relevant and emotionally appropriate to the learner's current situation.\"\n  },\n  {\n    role: \"user\",\n    content: `${contextPrompt}${additionalContext}\n\nReturn a JSON object with exactly this structure:\n{\n  \"replies\": [\"Reply 1\", \"Reply 2\", \"Reply 3\", \"Reply 4\", \"Reply 5\"]\n}\n\nMake replies:\n1. Contextually relevant to the specific handler and state\n2. Natural and conversational (how real learners talk)\n3. Actionable and specific\n4. Varied in intent (questions, confirmations, concerns, requests)\n5. Emotionally appropriate (encouraging for struggles, challenging for high performers)\n6. Under 10 words each`\n  }\n];\n\nreturn {\n  messages,\n  model: \"gpt-4o\",\n  temperature: 0.7,\n  max_tokens: 300,\n  response_format: { type: \"json_object\" },\n  // Pass through ALL the original data\n  originalData: $json\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -440,
        996
      ],
      "id": "9252856b-871a-41ad-b0a2-7997ec85d023",
      "name": "Smart Reply Generator Prompt"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://api.openai.com/v1/chat/completions",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "openAiApi",
        "sendBody": true,
        "bodyParameters": {
          "parameters": [
            {
              "name": "model",
              "value": "={{ $json.model }}"
            },
            {
              "name": "messages",
              "value": "={{ $json.messages }}"
            },
            {
              "name": "temperature",
              "value": "={{ $json.temperature }}"
            },
            {
              "name": "max_tokens",
              "value": "={{ $json.max_tokens }}"
            },
            {
              "name": "response_format",
              "value": "={{ $json.response_format }}"
            }
          ]
        },
        "options": {}
      },
      "id": "be9355ae-bbdf-4b0f-aaf7-ec6eb25b7433",
      "name": "Smart Reply Generator AI Call",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -220,
        996
      ],
      "credentials": {
        "openAiApi": {
          "id": "UFaW72U0IV5U0Ec5",
          "name": "OpenAi account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Process Smart Replies - Add generated replies to response\nconst smartReplies = JSON.parse($json.choices[0].message.content);\n\n// Get data from the pipeline (from Smart Reply Generator AI Call)\nconst originalData = $('Smart Reply Generator Prompt').first().json.originalData;\n\n// Add smart replies to the response\nconst enhancedResponse = {\n  ...originalData,\n  responseData: {\n    ...originalData.responseData,\n    toolData: {\n      ...originalData.responseData.toolData,\n      smartReplies: Array.isArray(smartReplies) ? smartReplies : Object.values(smartReplies)\n    }\n  }\n};\n\nreturn enhancedResponse;"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        0,
        996
      ],
      "id": "a9123ef0-e056-42af-b94b-ea17e8042447",
      "name": "Process Smart Replies"
    },
    {
      "parameters": {
        "jsCode": "// Generate Prompt Exercise - Creates targeted prompt exercises\nconst sessionId = $json.sessionId;\nconst session = $getWorkflowStaticData('global').sessions[sessionId];\n\nif (!session) {\n  throw new Error(`Session ${sessionId} not found in global state`);\n}\n\nconst messages = [\n  {\n    role: \"system\",\n    content: \"You are an expert instructional designer creating prompt engineering exercises for product managers. Create exercises that test practical application of AI concepts in product management contexts.\"\n  },\n  {\n    role: \"user\", \n    content: `Context:\n- Course Topic: ${$json.courseTopic}\n- Current Concept: ${session.currentConcept?.title || 'Unknown'}\n- Concept Summary: ${session.currentConcept?.summary || 'N/A'}\n- Learner Profile: ${$json.learnerProfile.role} at ${$json.learnerProfile.company}\n- Learner Skills: ${$json.learnerProfile.skills.join(', ')}\n\nKnowledge State:\n- Strengths: ${session.knowledgeStrengths?.join(', ') || 'None tracked yet'}\n- Gaps: ${session.knowledgeGaps?.join(', ') || 'None tracked yet'}\n- Recent Assessment Score: ${session.lastAssessmentScore || 'N/A'}/5\n\nPrevious Interactions:\n- Tools Used This Concept: ${session.currentConceptTools.join(', ')}\n- Recent Questions: ${session.recentQuestions?.slice(-2).join('; ') || 'None'}\n\n${session.orchestratorDecision?.exerciseFocus ? \n  `Special Focus: Create an exercise that specifically addresses: \"${session.orchestratorDecision.exerciseFocus}\"` : \n  'Create a prompt exercise that reinforces the current concept.'}\n\nGenerate a prompt exercise that:\n1. Is directly relevant to \"${session.currentConcept?.title}\"\n2. Tests practical application in their role as ${$json.learnerProfile.role}\n3. Addresses any identified knowledge gaps\n4. Builds on their existing strengths\n5. Is appropriately challenging based on their assessment score\n\nReturn JSON:\n{\n  \"task\": \"Clear, specific task description\",\n  \"context\": \"Brief scenario or context for the task\",\n  \"expectedOutcomes\": [\"What a good prompt should achieve\"],\n  \"hints\": [\"2-3 helpful hints without giving away the answer\"],\n  \"evaluationCriteria\": {\n    \"must_include\": [\"Key elements that must be in the prompt\"],\n    \"should_consider\": [\"Important considerations\"],\n    \"avoid\": [\"Common mistakes to avoid\"]\n  },\n  \"difficulty\": \"beginner|intermediate|advanced\",\n  \"targetedSkills\": [\"specific skills being tested\"]\n}`\n  }\n];\n\nreturn {\n  messages,\n  model: \"gpt-4o\",\n  temperature: 0.7,\n  max_tokens: 800,\n  response_format: { type: \"json_object\" },\n  originalData: $json\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1100,
        1475
      ],
      "id": "416674d5-87b5-46af-a5c7-919a8238d85f",
      "name": "Generate Prompt Exercise Prompt"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://api.openai.com/v1/chat/completions",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "openAiApi",
        "sendBody": true,
        "bodyParameters": {
          "parameters": [
            {
              "name": "model",
              "value": "={{ $json.model }}"
            },
            {
              "name": "messages",
              "value": "={{ $json.messages }}"
            },
            {
              "name": "temperature",
              "value": "={{ $json.temperature }}"
            },
            {
              "name": "max_tokens",
              "value": "={{ $json.max_tokens }}"
            },
            {
              "name": "response_format",
              "value": "={{ $json.response_format }}"
            }
          ]
        },
        "options": {}
      },
      "id": "5e690e44-8047-49c6-a2f3-3f43a7b4e778",
      "name": "Generate Prompt Exercise Evaluation AI Call",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -1980,
        650
      ],
      "credentials": {
        "openAiApi": {
          "id": "UFaW72U0IV5U0Ec5",
          "name": "OpenAi account"
        }
      }
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://api.openai.com/v1/chat/completions",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "openAiApi",
        "sendBody": true,
        "bodyParameters": {
          "parameters": [
            {
              "name": "model",
              "value": "={{ $json.model }}"
            },
            {
              "name": "messages",
              "value": "={{ $json.messages }}"
            },
            {
              "name": "temperature",
              "value": "={{ $json.temperature }}"
            },
            {
              "name": "max_tokens",
              "value": "={{ $json.max_tokens }}"
            },
            {
              "name": "response_format",
              "value": "={{ $json.response_format }}"
            }
          ]
        },
        "options": {}
      },
      "id": "155879f9-b6c2-48a0-8205-e6a2b1fc76e4",
      "name": "Generate Prompt Exercise Generate AI Call",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -880,
        1475
      ],
      "credentials": {
        "openAiApi": {
          "id": "UFaW72U0IV5U0Ec5",
          "name": "OpenAi account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// This node processes the AI's evaluation of the user's prompt\n\nconst evaluationResult = JSON.parse($json.choices[0].message.content);\n\n// Get data from the pipeline (from Generate Prompt Exercise Evaluation AI Call)\nconst originalData = $('Generate Evaluate Prompt Excercise Prompt').first().json.originalData;\nconst sessionId = originalData.sessionId;\nconst responseData = originalData.responseData;\n\n// Get session from global\nconst session = $getWorkflowStaticData('global').sessions[sessionId];\n\n// UPDATE STATE MACHINE\nsession.stateMachine.previousState = session.stateMachine.currentState;\nsession.stateMachine.currentState = 'prompt_evaluated';\nsession.stateMachine.stateHistory.push({\n  from: session.stateMachine.previousState,\n  to: 'prompt_evaluated',\n  action: 'evaluation_complete',\n  timestamp: new Date().toISOString(),\n  score: evaluationResult.score,\n  conceptId: session.currentConcept?.id,\n  conceptTitle: session.currentConcept?.title\n});\n\n// Update knowledge state based on evaluation\nif (evaluationResult.knowledgeUpdate) {\n  // Add mastered concepts to strengths\n  evaluationResult.knowledgeUpdate.masteredConcepts.forEach(concept => {\n    if (!session.knowledgeStrengths.includes(concept)) {\n      session.knowledgeStrengths.push(concept);\n    }\n  });\n  \n  // Update gaps - remove mastered ones, add new ones\n  session.knowledgeGaps = session.knowledgeGaps.filter(\n    gap => !evaluationResult.knowledgeUpdate.masteredConcepts.includes(gap)\n  );\n  \n  evaluationResult.knowledgeUpdate.identifiedGaps.forEach(gap => {\n    if (!session.knowledgeGaps.includes(gap)) {\n      session.knowledgeGaps.push(gap);\n    }\n  });\n  \n  // Track in knowledge evolution\n  if (!session.knowledgeEvolution) {\n    session.knowledgeEvolution = [];\n  }\n  \n  session.knowledgeEvolution.push({\n    timestamp: new Date().toISOString(),\n    tool: 'prompt_exercise',\n    concept: session.currentConcept.title,\n    conceptId: session.currentConcept.id,\n    score: evaluationResult.score,\n    mastered: evaluationResult.knowledgeUpdate.masteredConcepts,\n    gaps: evaluationResult.knowledgeUpdate.identifiedGaps,\n    reasoning: evaluationResult.knowledgeUpdate.reasoning\n  });\n}\n\n// Clear pending evaluation\nsession.pendingPromptEvaluation = null;\n\n// Save updated state\n$getWorkflowStaticData('global').sessions[sessionId] = session;\n\n// Create updated response data with evaluation results\nconst updatedResponseData = {\n  ...responseData,\n  toolData: {\n    ...responseData.toolData,\n    evaluationResult: evaluationResult\n  },\n  waitingForInput: false,\n  nextAction: 'Click Next to continue to the next concept.'\n};\n\n// Pass all necessary data forward in the pipeline\nreturn {\n  ...originalData,\n  evaluationResult,\n  responseData: updatedResponseData,\n  sessionId,\n  learnerProfile: originalData.learnerProfile\n};"
      },
      "id": "dcb4dc48-f098-4724-a2a1-cec696236b15",
      "name": "Process Prompt Evaluation",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1760,
        650
      ]
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// Generate Assessment Grading Prompt - FIXED to properly get learner answer\nconst sessionId = $json.sessionId;\nconst session = $getWorkflowStaticData('global').sessions[sessionId];\n\nif (!session) {\n  throw new Error(`Session ${sessionId} not found in global state`);\n}\n\n// Get the learner's answer from the input\nconst learnerAnswer = $json.learnerInput?.answer;\n\nif (!learnerAnswer) {\n  throw new Error('No learner answer found in the input');\n}\n\nconst messages = [\n  {\n    role: \"system\",\n    content: \"You are an expert instructional coach who evaluates learner understanding AND tracks their evolving knowledge state. Analyze both the current answer and overall knowledge progression.\"\n  },\n  {\n    role: \"user\", \n    content: `Context:\n- Course Topic: ${$json.courseTopic}\n- Current Concept: ${session.currentConcept.title}\n- Question: ${session.currentConcept.assessmentQuestion}\n- Correct Answer: ${session.currentConcept.correctAnswer}\n- Learner's Answer: ${learnerAnswer}\n- Learner Profile: ${$json.learnerProfile.role} at ${$json.learnerProfile.company}\n\nCurrent Knowledge State:\n- Strengths: ${session.knowledgeStrengths?.join(', ') || 'None tracked yet'}\n- Gaps: ${session.knowledgeGaps?.join(', ') || 'None tracked yet'}\n\nAssessment Context:\n- Is this a dynamic concept?: ${session.currentConcept.isDynamic || false}\n- Targeted gaps (if dynamic): ${session.currentConcept.targetedGaps?.join(', ') || 'N/A'}\n- Previous score: ${session.lastAssessmentScore || 'N/A'}\n\nEvaluate the answer AND update their knowledge state. Return JSON:\n{\n  \"score\": (0-5 number),\n  \"feedback\": \"Brief, encouraging feedback\",\n  \"understood\": (true or false),\n  \"knowledgeUpdate\": {\n    \"updatedStrengths\": [\"Complete list of what learner knows well\"],\n    \"updatedGaps\": [\"Complete list of significant gaps needing attention\"],\n    \"reasoning\": \"Brief explanation of knowledge state changes\"\n  }\n}\n\nGrading Rules:\n- 5: Perfect understanding\n- 4: Good understanding with minor gaps\n- 3: Adequate understanding for progression\n- 2: Significant gaps but some understanding\n- 0-1: Major misunderstanding\n\nKnowledge Rules:\n- Add strengths for demonstrated understanding (scores 3+)\n- Remove gaps that were successfully addressed\n- Only list actionable, specific gaps\n- For dynamic concepts addressing gaps, be generous if progress is shown\n- Empty gaps array means no significant issues`\n  }\n];\n\nreturn {\n  messages,\n  model: \"gpt-4o\",\n  temperature: 0.3,\n  max_tokens: 400,\n  response_format: { type: \"json_object\" },\n  // Pass through all necessary data for processing\n  originalData: {\n    sessionId: $json.sessionId,\n    courseTopic: $json.courseTopic,\n    learnerAnswer: learnerAnswer,\n    learnerProfile: $json.learnerProfile,\n    learnerInput: $json.learnerInput\n  }\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -2200,
        450
      ],
      "id": "97e7cdd3-0dda-4a51-a87f-027d600f8e96",
      "name": "Generate Assessment Grading Prompt"
    },
    {
      "parameters": {
        "jsCode": "// Process Generated Prompt Exercise - FIXED\nconst exerciseData = JSON.parse($json.choices[0].message.content);\n\n// Get data from the pipeline\nconst sessionId = $('Generate Prompt Exercise Prompt').first().json.originalData.sessionId;\nconst originalData = $('Generate Prompt Exercise Prompt').first().json.originalData;\n\n// Get session from global\nconst session = $getWorkflowStaticData('global').sessions[sessionId];\n\n// Store the enhanced task in session\nsession.currentPromptExercise = exerciseData;\n\n// Save updated state\n$getWorkflowStaticData('global').sessions[sessionId] = session;\n\n// HERE'S THE KEY: Build the response with the ACTUAL enhanced task data\nconst responseData = {\n  sessionId,\n  toolType: 'prompt_exercise',\n  conceptProgress: {\n    current: session.completedConcepts.length + 1,\n    total: session.remainingCoreConcepts.length + \n           session.completedConcepts.length + \n           session.insertedConcepts.length\n  },\n  toolData: {\n    task: exerciseData.task,  // Use the actual generated task\n    context: exerciseData.context,\n    hints: exerciseData.hints,\n    conceptTitle: session.currentConcept?.title,\n    difficulty: exerciseData.difficulty\n  },\n  waitingForInput: true,\n  inputType: 'prompt',\n  message: 'Practice your prompt engineering skills with this task.'\n};\n\n// Pass the enhanced response forward\nreturn {\n  ...originalData,\n  responseData,  // This contains the enhanced task\n  sessionId,\n  learnerProfile: originalData.learnerProfile\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -660,
        1475
      ],
      "id": "e6190bba-709c-48a2-8d93-30e2c021145f",
      "name": "Process Generated Prompt Exercise"
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// Adaptive Orchestrator Router Prompt - WITH PROMPT EXERCISE INTELLIGENCE\n// Get session directly from global\nconst sessionId = $json.sessionId;\nconst session = $getWorkflowStaticData('global').sessions[sessionId];\n\nif (!session) {\n  throw new Error(`Session ${sessionId} not found in global state`);\n}\n\nconst messages = [\n  {\n    role: \"system\",\n    content: \"You are an adaptive learning orchestrator. Analyze the current learning state and decide the next best action for the learner. When learner notes are provided, carefully analyze them to determine if the learner needs clarification, wants to skip, is ready to progress, or would benefit from additional content. You can also decide whether to grade a pending assessment or skip grading based on the learner's needs. You can also decide whether to evaluate a pending prompt exercise evaluation or skip prompt exercise evaluation based on learner's needs.\"\n  },\n  {\n    role: \"user\", \n    content: `Current State Machine:\n- Current State: ${session.stateMachine.currentState}\n- Previous State: ${session.stateMachine.previousState || 'None'}\n- Pending Grading: ${session.stateMachine.currentState === 'assessment_submitted'}\n${session.stateMachine.currentState === 'welcome' && session.currentConcept ? '- Note: This is the first concept after welcome' : ''}\n\nCurrent Learning State:\n- Course Topic: ${$json.courseTopic}\n- Current Concept: ${session.currentConcept?.title || 'None'}\n- Concept Summary: ${session.currentConcept?.summary || 'N/A'}\n- Tools Already Used: ${session.currentConceptTools.join(', ') || 'None'}\n- Last Assessment Score: ${session.lastAssessmentScore || 'N/A'}/5\n- Knowledge Gaps: ${session.knowledgeGaps?.join(', ') || 'None'}\n- Gap Attempts: ${JSON.stringify(session.gapAttempts || {})}\n- Recent Questions: ${session.recentQuestions?.join('; ') || 'None'}\n- Completed Concepts: ${session.completedConcepts.length}\n- Remaining Core Concepts: ${session.remainingCoreConcepts.length}\n\nPROMPT EXERCISE DECISION RULES:\n${!session.currentConceptTools.includes('prompt_exercise') ? `\n- Current concept title: \"${session.currentConcept?.title}\"\n- Has prompt task defined: ${session.currentConcept?.shouldHavePromptTask ? 'Yes' : 'No'}\n\nShould we use prompt_exercise tool? Consider:\n1. Is the concept about prompting, prompt engineering, or AI interaction?\n   - Look for keywords: \"prompt\", \"AI\", \"GPT\", \"LLM\", \"query\", \"instruction\"\n   - Check if title contains: \"${session.currentConcept?.title}\"\n   \n2. Has the learner already shown good understanding?\n   - Last assessment score: ${session.lastAssessmentScore || 'N/A'}\n   - If score >= 4 AND concept relates to prompting → prompt_exercise\n   \n3. Is practical application important for this concept?\n   - If the concept teaches a skill that requires practice → consider prompt_exercise\n   \n4. Tool progression logic:\n   - If only concept_card used → usually go to assessment\n   - If assessment score is high AND concept is prompt-related → prompt_exercise\n   - If assessment score is low → consider insert_concept instead\n` : 'Prompt exercise already used for this concept'}\n\n${$json.learnerInput?.note ? `\nIMPORTANT - LEARNER NOTE ANALYSIS REQUIRED:\nThe learner just submitted this note/question with their input:\n\"${$json.learnerInput.note}\"\n\nCurrent Concept Being Studied: ${session.currentConcept?.title}\nConcept Summary: ${session.currentConcept?.summary || 'N/A'}\n\nAnalyze this note carefully to determine:\n1. Is the learner confused or asking for clarification? \n   - Look for: question marks, words like \"confused\", \"don't understand\", \"unclear\", \"help\"\n   - If yes → strongly consider insert_concept to address the confusion\n\n2. Is the learner showing understanding and ready to move on?\n   - Look for: \"I get it\", \"makes sense\", \"understood\", \"ready\"\n   - If yes → proceed to assessment\n\n3. Is the learner making connections or showing deeper thinking?\n   - Look for: relating to their role/experience, asking advanced questions, making analogies\n   - If yes AND prior assessment scores are high → consider prompt_exercise\n\n4. Does the note reveal specific knowledge gaps?\n   - Look for: misconceptions, incorrect assumptions, missing foundational knowledge\n   - If yes → insert_concept with specific focus on the gap\n\n5. Is the learner asking for examples or application to their role?\n   - Look for: \"example\", \"how does this apply\", \"in practice\", \"for ${$json.learnerProfile?.role}\"\n   - If yes → insert_concept with practical examples\n` : ''}\n\n${session.pendingAssessment ? `\nPENDING ASSESSMENT:\n- Answer submitted: \"${session.pendingAssessment.answer}\"\n- Note submitted: \"${session.pendingAssessment.note}\"\n- Question was: \"${session.pendingAssessment.question}\"\n\nYou must decide whether to:\n1. Grade the assessment (nextAction: \"grade_assessment\")\n2. Skip grading and move to something else based on the note content\n` : ''}\n\n${session.pendingPromptEvaluation ? `\nPENDING PROMPT EVALUATION:\n- Prompt submitted: \"${session.pendingPromptEvaluation.prompt}\"\n- Note submitted: \"${session.pendingPromptEvaluation.note || 'None'}\"\n- Task was: \"${session.pendingPromptEvaluation.task}\"\n\nYou must decide whether to:\n1. Evaluate the prompt (nextAction: \"evaluate_prompt\")\n2. Skip evaluation and do something else based on the note content\n\nDecision Rules for Prompt Exercise with Notes:\n1. If learner shows confusion or asks for help with prompting:\n   - Set skipEvaluation: true\n   - Set nextAction: \"insert_concept\" with focus on prompt engineering\n2. If learner wants to skip or says they understand:\n   - Set skipEvaluation: true\n   - Set nextAction: \"concept_complete\"\n3. If learner asks for feedback despite note:\n   - Set nextAction: \"evaluate_prompt\" (they want the evaluation)\n4. Otherwise, proceed with evaluation:\n   - Set nextAction: \"evaluate_prompt\"\n` : ''}\n\nDecision Rules:\n1. Always start new concepts with concept_card\n2. After concept_card, if concept is prompt-related (title contains \"prompt\", \"AI\", \"engineering\") AND no assessment yet → consider prompt_exercise before assessment\n3. If learner explicitly asks to skip (e.g., \"skip this\", \"I know this\", \"move on\"):\n   - Set skipGrading: true (if assessment pending)\n   - Set skipEvaluation: true (if prompt evaluation pending)\n   - Set markAsComplete: true with completionType: \"skipped\"\n   - Set nextAction: \"concept_complete\"\n4. If learner shows severe confusion and has pending assessment/prompt:\n   - Set skipGrading/skipEvaluation: true (evaluation won't help)\n   - Set nextAction: \"insert_concept\" to address confusion\n5. Normal progression for NON-prompt concepts:\n   - concept_card → assessment → (if score low: insert_concept, if high: concept_complete)\n6. Normal progression for PROMPT-RELATED concepts:\n   - concept_card → assessment → (if score >= 3: prompt_exercise) → concept_complete\n\n${$json.learnerInput?.note ? 'IMPORTANT: The learner note should heavily influence your decision. Prioritize addressing their specific question or concern.' : ''}\n\nReturn JSON:\n{\n  \"nextAction\": \"grade_assessment|evaluate_prompt|concept_card|assessment|prompt_exercise|concept_complete|insert_concept\",\n  \"reasoning\": \"Brief explanation of decision\",\n  \"skipGrading\": true|false (only if assessment is pending),\n  \"skipEvaluation\": true|false (only if prompt evaluation is pending),\n  \"markAsComplete\": true|false (if learner wants to skip),\n  \"completionType\": \"normal|skipped\" (if markAsComplete is true),\n  \"skipReason\": \"reason for skipping if applicable\",\n  \"exerciseFocus\": \"specific focus for prompt exercise if choosing that tool\",\n  \"conceptNeeded\": {\n    \"reason\": \"specific gap to address if action is insert_concept\",\n    \"focus\": \"topic area for new concept if inserting\"\n  },\n  \"noteAnalysis\": {\n    \"understanding\": \"low|medium|high\",\n    \"needsClarification\": true|false,\n    \"wantsToSkip\": true|false,\n    \"specificRequest\": \"what they are asking for if clear\",\n    \"sentiment\": \"confused|curious|confident|frustrated|dismissive\"\n  }\n}`\n  }\n];\n\nreturn {\n  messages,\n  model: \"gpt-4o\",\n  temperature: 0.3,\n  max_tokens: 500,\n  response_format: { type: \"json_object\" },\n  // Pass through original data WITHOUT sessionState\n  originalData: {\n    sessionId: $json.sessionId,\n    action: $json.action,\n    learnerInput: $json.learnerInput,\n    courseTopic: $json.courseTopic,\n    learnerProfile: $json.learnerProfile,\n    coreConcepts: $json.coreConcepts,\n    userName: $json.userName,\n    currentConcept: session.currentConcept, // Include current concept for reference\n    stateMachine: {\n      currentState: session.stateMachine.currentState // Only pass minimal state info\n    }\n  }\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -3080,
        875
      ],
      "id": "f9a1ca2c-49f9-4744-8b06-e7a2db88352f",
      "name": "Generate Adaptive Orchestrator Router Prompt"
    },
    {
      "parameters": {
        "jsCode": "// This node prepares the prompt for evaluating user's prompt exercise submission\n\n// Prepare Prompt Evaluation Request\nconst sessionId = $json.sessionId;\nconst session = $getWorkflowStaticData('global').sessions[sessionId];\n\nif (!session || !session.pendingPromptEvaluation) {\n  throw new Error('No pending prompt evaluation found');\n}\n\nconst messages = [\n  {\n    role: \"system\",\n    content: \"You are an expert at evaluating AI prompts for product management tasks AND tracking knowledge mastery. Analyze both the prompt quality and what it reveals about the learner's understanding.\"\n  },\n  {\n    role: \"user\",\n    content: `Task: ${session.pendingPromptEvaluation.task}\nLearner's Prompt: ${session.pendingPromptEvaluation.prompt}\nLearner Background: ${$json.learnerProfile.role} with skills in ${$json.learnerProfile.skills.join(', ')}\n\nEvaluation Criteria:\n${JSON.stringify(session.pendingPromptEvaluation.evaluationCriteria || {})}\n\nCurrent Knowledge State:\n- Strengths: ${session.knowledgeStrengths?.join(', ') || 'None'}\n- Gaps: ${session.knowledgeGaps?.join(', ') || 'None'}\n\nEvaluate the prompt and return a JSON object with this exact structure:\n{\n  \"score\": (0-5 number),\n  \"feedback\": \"Constructive feedback on the prompt quality\",\n  \"strengths\": [\"what they did well\"],\n  \"improvements\": [\"specific suggestions\"],\n  \"simulatedAIResponse\": \"What an AI would generate from this prompt\",\n  \"knowledgeUpdate\": {\n    \"masteredConcepts\": [\"concepts demonstrated mastery of\"],\n    \"identifiedGaps\": [\"gaps revealed by the prompt\"],\n    \"reasoning\": \"Brief explanation of knowledge assessment\"\n  }\n}`\n  }\n];\n\nreturn {\n  messages,\n  model: \"gpt-4o\",\n  temperature: 0.3,\n  max_tokens: 800,\n  response_format: { type: \"json_object\" },\n  // Pass through all data needed for processing\n  originalData: {\n    sessionId: $json.sessionId,\n    courseTopic: $json.courseTopic,\n    learnerProfile: $json.learnerProfile,\n    pendingPromptEvaluation: session.pendingPromptEvaluation,\n    currentConcept: session.currentConcept,\n    // IMPORTANT: Construct the responseData here\n    responseData: {\n      sessionId: $json.sessionId,\n      toolType: 'prompt_exercise',\n      conceptProgress: {\n        current: session.completedConcepts.length + 1,\n        total: session.remainingCoreConcepts.length + \n               session.completedConcepts.length + \n               session.insertedConcepts.length\n      },\n      toolData: {\n        task: session.pendingPromptEvaluation?.task || session.currentPromptExercise?.task || session.currentConcept?.promptTask,\n        context: session.currentPromptExercise?.context,\n        hints: session.currentPromptExercise?.hints || [],\n        conceptTitle: session.currentConcept?.title,\n        difficulty: session.currentPromptExercise?.difficulty || 'intermediate'\n      },\n      waitingForInput: false,\n      inputType: 'evaluation',\n      message: 'Evaluating your prompt...'\n    }\n  }\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -2200,
        650
      ],
      "id": "a299c4ff-0b80-4938-afab-d09598f8d1d4",
      "name": "Generate Evaluate Prompt Excercise Prompt"
    },
    {
      "parameters": {
        "rules": {
          "values": [
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "id": "588c31ce-db6d-4b78-9dd0-bc639d4e4553",
                    "leftValue": "={{ $json.nextAction }}",
                    "rightValue": "grade_assessment",
                    "operator": {
                      "type": "string",
                      "operation": "equals",
                      "name": "filter.operator.equals"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "gradeAssessment"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "id": "60aca0f7-b783-4e53-a0b2-153342db2528",
                    "leftValue": "={{ $json.nextAction }}",
                    "rightValue": "generate_prompt_exercise",
                    "operator": {
                      "type": "string",
                      "operation": "equals",
                      "name": "filter.operator.equals"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "evaluatePrompt"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "id": "c41e007c-c9f8-4e01-9c3b-f5416eaa4575",
                    "leftValue": "={{ $json.nextAction }}",
                    "rightValue": "=concept_complete",
                    "operator": {
                      "type": "string",
                      "operation": "equals"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "completeConcept"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "leftValue": "={{ ['concept_card', 'assessment', 'prompt_exercise'].includes($json.nextAction) }}",
                    "rightValue": "={{ true }}",
                    "operator": {
                      "type": "boolean",
                      "operation": "true",
                      "singleValue": true
                    },
                    "id": "252d4b84-cc5a-482b-b966-c78ad46410f5"
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "coreToolRouter"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "id": "6131214d-57dc-4724-a4ee-daa86b8687ff",
                    "leftValue": "={{ $json.nextAction }}",
                    "rightValue": "=insert_concept",
                    "operator": {
                      "type": "string",
                      "operation": "equals"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "insertNewConcept"
            }
          ]
        },
        "options": {}
      },
      "id": "f5228f95-c6dc-40f9-97df-140e78e2d91b",
      "name": "Adaptive Tool Router",
      "type": "n8n-nodes-base.switch",
      "typeVersion": 3.2,
      "position": [
        -2420,
        833
      ]
    },
    {
      "parameters": {
        "rules": {
          "values": [
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "leftValue": "={{ ['concept_card', 'insert_concept'].includes($json.nextAction) }}",
                    "rightValue": "concept_card",
                    "operator": {
                      "type": "boolean",
                      "operation": "true",
                      "singleValue": true
                    },
                    "id": "tool1"
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "conceptCard"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "leftValue": "={{ $json.nextAction }}",
                    "rightValue": "assessment",
                    "operator": {
                      "type": "string",
                      "operation": "equals"
                    },
                    "id": "tool2"
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "assessment"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "leftValue": "={{ $json.nextAction }}",
                    "rightValue": "prompt_exercise",
                    "operator": {
                      "type": "string",
                      "operation": "equals"
                    },
                    "id": "tool3"
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "promptExercise"
            }
          ]
        },
        "options": {}
      },
      "id": "97285030-bdb0-4979-a0b5-897aa39d3635",
      "name": "Core Tool Router",
      "type": "n8n-nodes-base.switch",
      "typeVersion": 3.2,
      "position": [
        -1540,
        1275
      ]
    },
    {
      "parameters": {
        "jsCode": "// Fix for Welcome Message Handler\n// Location: \"Welcome Message\" node\n\nconst sessionId = $json.sessionId;\nconst courseTopic = $json.courseTopic;\n\n// Get session from global\nconst session = $getWorkflowStaticData('global').sessions[sessionId];\n\n// UPDATE STATE MACHINE\nsession.stateMachine.previousState = session.stateMachine.currentState;\nsession.stateMachine.currentState = 'welcome';\nsession.stateMachine.stateHistory.push({\n  from: session.stateMachine.previousState,\n  to: 'welcome',\n  action: 'show_welcome',\n  timestamp: new Date().toISOString()\n});\n\n// Save updated state\n$getWorkflowStaticData('global').sessions[sessionId] = session;\n\nconst responseData = {\n  sessionId,\n  toolType: 'welcome',\n  toolData: {\n    title: `Welcome to: ${courseTopic}`,\n    message: 'This adaptive course will guide you through 10 core concepts with personalized instruction based on your progress.',\n    instructions: 'Click Next to begin with the first concept.'\n  },\n  waitingForInput: false,\n  nextAction: 'start_course'\n};\n\nreturn {\n  ...($json),\n  responseData\n};"
      },
      "id": "a9b558e5-f16a-498d-8536-c91f695bfb65",
      "name": "Welcome Message Handler",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        0,
        200
      ]
    },
    {
      "parameters": {
        "jsCode": "// Fix for Complete Concept Handler\n// Location: \"Complete Concept\" node\n\nconst sessionId = $json.sessionId;\nconst currentConcept = $json.currentConcept || $json.sessionState?.currentConcept;\nconst session = $getWorkflowStaticData('global').sessions[sessionId];\n\nif (!currentConcept) {\n  console.log('Warning: No current concept to complete');\n}\n\n// UPDATE STATE MACHINE - Track concept completion\nsession.stateMachine.previousState = session.stateMachine.currentState;\nsession.stateMachine.currentState = 'concept_completing';\nsession.stateMachine.stateHistory.push({\n  from: session.stateMachine.previousState,\n  to: 'concept_completing',\n  action: 'complete_concept',\n  timestamp: new Date().toISOString(),\n  completedConceptId: currentConcept?.id,\n  completedConceptTitle: currentConcept?.title,\n  wasSkipped: session.skippedConcepts?.some(skip => skip.conceptId === currentConcept?.id),\n  finalScore: session.lastAssessmentScore\n});\n\n// Mark current concept as completed ONLY if we have one and it's not already completed\nif (currentConcept && !session.completedConcepts.includes(currentConcept.id)) {\n  session.completedConcepts.push(currentConcept.id);\n  \n  console.log(`Completed concept ${currentConcept.id}: ${currentConcept.title}`);\n  console.log(`Total completed: ${session.completedConcepts.length}`);\n  \n  // Note: We already removed it from remainingCoreConcepts when we started it\n  // So we don't need to remove it again here\n}\n\n// Check if this was a skipped concept\nconst wasSkipped = session.skippedConcepts?.some(\n  skip => skip.conceptId === currentConcept?.id\n);\n\n// Add metadata to completion\nif (!session.completionMetadata) session.completionMetadata = {};\nif (currentConcept) {\n  session.completionMetadata[currentConcept.id] = {\n    completedAt: new Date().toISOString(),\n    wasSkipped: wasSkipped,\n    toolsUsed: session.currentConceptTools,\n    assessmentScore: session.lastAssessmentScore,\n    completionType: wasSkipped ? 'skipped' : \n                    session.lastAssessmentScore >= 4 ? 'mastered' :\n                    session.lastAssessmentScore >= 3 ? 'adequate' : 'struggled'\n  };\n}\n\n// Reset for next concept - INCLUDING PROMPT EXERCISE CLEANUP\nsession.currentConcept = null;\nsession.currentConceptTools = [];\nsession.lastToolUsed = null;\nsession.lastAssessmentScore = null;\nsession.knowledgeGaps = [];\nsession.currentPromptExercise = null; // Clear the enhanced prompt exercise\nsession.currentExerciseFocus = null; // Clear any exercise focus from orchestrator\nsession.pendingAssessment = null;\nsession.pendingPromptEvaluation = null;\n\n// Save updated state\n$getWorkflowStaticData('global').sessions[sessionId] = session;\n\n// Prepare response to move to next concept\nconst responseData = {\n  sessionId,\n  toolType: 'transition',\n  conceptProgress: {\n    current: session.completedConcepts.length,\n    total: session.remainingCoreConcepts.length + \n           session.completedConcepts.length + \n           session.insertedConcepts.length\n  },\n  toolData: {\n    completedConcept: currentConcept?.title || 'Unknown',\n    message: 'Moving to next concept...'\n  },\n  waitingForInput: false,\n  nextAction: 'auto_continue'\n};\n\n// Debug info\nconsole.log(`Remaining concepts: ${session.remainingCoreConcepts.join(', ')}`);\nconsole.log(`State: ${session.stateMachine.currentState}`);\n\nreturn {\n  ...($json),\n  responseData,\n  moveToNext: true,\n  sessionState: session // Pass session state for debugging\n};"
      },
      "id": "f72aae0f-7529-4acb-96c6-6dae7ff03cef",
      "name": "Complete Concept Handler",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -660,
        875
      ]
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// Fix for Insert Concept Handler\n// Location: \"Insert Concept\" node\n\nconst newConcept = JSON.parse($json.choices[0].message.content);\n\n// Get data from the pipeline (from Generate New Concept AI Call)\nconst sessionId = $('Generate New Concept Prompt').first().json.originalData.sessionId;\nconst originalData = $('Generate New Concept Prompt').first().json.originalData;\n\nconst orchestratorDecision = originalData.orchestratorDecision;\n\n// Add metadata to new concept\nnewConcept.id = `dynamic_${Date.now()}`;\nnewConcept.isCore = false;\nnewConcept.isDynamic = true;\n\n// Get session from global directly\nconst session = $getWorkflowStaticData('global').sessions[sessionId];\n\n// UPDATE STATE MACHINE - Track dynamic concept insertion\nsession.stateMachine.previousState = session.stateMachine.currentState;\nsession.stateMachine.currentState = 'dynamic_concept_inserted';\nsession.stateMachine.stateHistory.push({\n  from: session.stateMachine.previousState,\n  to: 'dynamic_concept_inserted',\n  action: 'insert_dynamic_concept',\n  timestamp: new Date().toISOString(),\n  dynamicConceptId: newConcept.id,\n  dynamicConceptTitle: newConcept.title,\n  targetedGap: orchestratorDecision.conceptNeeded.reason || session.knowledgeGaps[0],\n  previousConceptId: session.currentConcept?.id,\n  previousConceptTitle: session.currentConcept?.title\n});\n\n// Set targeted gaps from orchestrator decision\nconst targetGap = orchestratorDecision.conceptNeeded.reason || session.knowledgeGaps[0];\nnewConcept.targetedGaps = [targetGap];\nnewConcept.targetedGap = targetGap; // Keep both for compatibility\n\n// Increment the attempt counter for this gap\nif (targetGap) {\n  if (!session.gapAttempts) session.gapAttempts = {};\n  session.gapAttempts[targetGap] = (session.gapAttempts[targetGap] || 0) + 1;\n  newConcept.attemptNumber = session.gapAttempts[targetGap];\n}\n\n// IMPORTANT: Mark the struggling concept as completed so we don't return to it\nif (session.currentConcept && session.currentConcept.isCore) {\n  // Add the original concept to completed list\n  session.completedConcepts.push(session.currentConcept.id);\n  \n  // Remove it from remaining core concepts\n  session.remainingCoreConcepts = session.remainingCoreConcepts.filter(\n    id => id !== session.currentConcept.id\n  );\n}\n\n// Set the new concept as current\nsession.currentConcept = newConcept;\nsession.currentConceptTools = []; // Fresh start for the new concept\nsession.lastToolUsed = null;\n\n// Track the inserted dynamic concept\nsession.insertedConcepts.push(newConcept.id);\n\n// Clear previous assessment data since this is a new concept\nsession.lastAssessmentScore = null;\nsession.knowledgeGaps = []; // Clear the gaps\n\n// Save updated state back to global\n$getWorkflowStaticData('global').sessions[sessionId] = session;\n\n// Return with the updated current concept\nreturn {\n  ...originalData,\n  currentConcept: newConcept,\n  nextAction: 'concept_card',\n  newConceptInserted: true\n};"
      },
      "id": "2a8037fd-8e39-45da-9c9c-1410bd4c5133",
      "name": "Insert Concept Handler",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1760,
        1371
      ]
    }
  ],
  "pinData": {},
  "connections": {
    "Main Webhook": {
      "main": [
        [
          {
            "node": "Init Course Data",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Session State Manager": {
      "main": [
        [
          {
            "node": "Core Orchestrator",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Concept Card Handler": {
      "main": [
        [
          {
            "node": "Smart Reply Generator Prompt",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Assessment Handler": {
      "main": [
        [
          {
            "node": "Smart Reply Generator Prompt",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Process Grading": {
      "main": [
        [
          {
            "node": "Smart Reply Generator Prompt",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prompt Exercise Handler": {
      "main": [
        [
          {
            "node": "Generate Prompt Exercise Prompt",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Course Completion": {
      "main": [
        [
          {
            "node": "Merge Responses",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge Responses": {
      "main": [
        [
          {
            "node": "Limit Data",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Reset Session Webhook": {
      "main": [
        [
          {
            "node": "Reset Session",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Reset Session": {
      "main": [
        [
          {
            "node": "Reset Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Init Course Data": {
      "main": [
        [
          {
            "node": "Session State Manager",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Limit Data": {
      "main": [
        [
          {
            "node": "Webhook Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "When clicking 'Test workflow'": {
      "main": [
        [
          {
            "node": "Edit Fields",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Edit Fields": {
      "main": [
        [
          {
            "node": "Init Course Data",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Grade Assessment AI Call": {
      "main": [
        [
          {
            "node": "Process Grading",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Generate New Concept Prompt": {
      "main": [
        [
          {
            "node": "Generate New Concept AI Call",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Generate New Concept AI Call": {
      "main": [
        [
          {
            "node": "Insert Concept Handler",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Core Orchestrator": {
      "main": [
        [
          {
            "node": "Core Router",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Core Router": {
      "main": [
        [
          {
            "node": "Course Completion",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Welcome Message Handler",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Generate Assessment Grading Prompt",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Generate Evaluate Prompt Excercise Prompt",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Generate Adaptive Orchestrator Router Prompt",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Generate Adaptive Orchestrator Router Prompt",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Adaptive Orchestrator AI Call": {
      "main": [
        [
          {
            "node": "Process Adaptive Orchestrator Decision",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Process Adaptive Orchestrator Decision": {
      "main": [
        [
          {
            "node": "Adaptive Tool Router",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Smart Reply Generator Prompt": {
      "main": [
        [
          {
            "node": "Smart Reply Generator AI Call",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Smart Reply Generator AI Call": {
      "main": [
        [
          {
            "node": "Process Smart Replies",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Process Smart Replies": {
      "main": [
        [
          {
            "node": "Merge Responses",
            "type": "main",
            "index": 2
          }
        ]
      ]
    },
    "Generate Prompt Exercise Prompt": {
      "main": [
        [
          {
            "node": "Generate Prompt Exercise Generate AI Call",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Generate Prompt Exercise Generate AI Call": {
      "main": [
        [
          {
            "node": "Process Generated Prompt Exercise",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Generate Prompt Exercise Evaluation AI Call": {
      "main": [
        [
          {
            "node": "Process Prompt Evaluation",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Process Prompt Evaluation": {
      "main": [
        [
          {
            "node": "Smart Reply Generator Prompt",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Generate Assessment Grading Prompt": {
      "main": [
        [
          {
            "node": "Grade Assessment AI Call",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Process Generated Prompt Exercise": {
      "main": [
        [
          {
            "node": "Smart Reply Generator Prompt",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Generate Adaptive Orchestrator Router Prompt": {
      "main": [
        [
          {
            "node": "Adaptive Orchestrator AI Call",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Generate Evaluate Prompt Excercise Prompt": {
      "main": [
        [
          {
            "node": "Generate Prompt Exercise Evaluation AI Call",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Adaptive Tool Router": {
      "main": [
        [
          {
            "node": "Generate Assessment Grading Prompt",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Generate Evaluate Prompt Excercise Prompt",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Complete Concept Handler",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Core Tool Router",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Generate New Concept Prompt",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Core Tool Router": {
      "main": [
        [
          {
            "node": "Concept Card Handler",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Assessment Handler",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Prompt Exercise Handler",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Welcome Message Handler": {
      "main": [
        [
          {
            "node": "Merge Responses",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Complete Concept Handler": {
      "main": [
        [
          {
            "node": "Smart Reply Generator Prompt",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Insert Concept Handler": {
      "main": [
        [
          {
            "node": "Core Tool Router",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": true,
  "settings": {
    "executionOrder": "v1"
  },
  "versionId": "c9f58253-9f45-466d-b96d-7ee367d6ad08",
  "meta": {
    "instanceId": "eea8bfa4918320bc469ce323a7b217b8209b639e450c67bc3e6a88bdf340b7de"
  },
  "id": "Qlx31TQjyEw9zg9C",
  "tags": []
}