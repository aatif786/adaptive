{
  "name": "My workflow 7",
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "adaptive-instructor",
        "responseMode": "responseNode",
        "options": {}
      },
      "id": "d532845c-49cb-4830-97a8-b4acf2f0c1c1",
      "name": "Main Webhook",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 1.1,
      "position": [
        -4180,
        450
      ],
      "webhookId": "9ef00e80-0d3e-4fcb-b8ff-e621ee6fc02e"
    },
    {
      "parameters": {
        "jsCode": "// CLEAN Session State Manager - ONLY manages state storage\n// No business logic, no routing, no decisions\n\nconst sessionId = $json.sessionId || 'default-session';\nconst action = $json.action || 'start';\nconst learnerInput = $json.learnerInput || {};\n\n// Initialize global state store if needed\nlet globalState = $getWorkflowStaticData('global');\nif (!globalState.sessions) {\n  globalState.sessions = {};\n}\n\n// Initialize new session ONLY if it doesn't exist or action is 'start'\nif (!globalState.sessions[sessionId] || action === 'start') {\n  globalState.sessions[sessionId] = {\n    // Learning state\n    currentConceptIndex: 0,\n    completedConcepts: [],\n    remainingCoreConcepts: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10],\n    insertedConcepts: [],\n    interactionHistory: [],\n    currentConcept: null,\n    lastToolUsed: null,\n    currentConceptTools: [],\n    lastAssessmentScore: null,\n    knowledgeGaps: [],\n    knowledgeStrengths: [],\n    knowledgeEvolution: [],\n    assessmentHistory: [],\n    gapAttempts: {},\n    deferredGaps: [],\n    gapConceptHistory: {},\n    pendingAssessment: null,\n    recentQuestions: [],\n    \n    // State Machine (isolated in global)\n    stateMachine: {\n      currentState: 'uninitialized',\n      previousState: null,\n      stateHistory: [],\n      lastTransition: null\n    },\n    \n    // Metadata\n    createdAt: new Date().toISOString(),\n    lastUpdated: new Date().toISOString()\n  };\n}\n\n// That's it! Just pass through the request data\n// Other nodes will read state directly and make decisions\nreturn {\n  sessionId,\n  action,\n  learnerInput,\n  courseTopic: $json.courseTopic,\n  learnerProfile: $json.learnerProfile,\n  coreConcepts: $json.coreConcepts,\n  userName: $json.userName\n};"
      },
      "id": "f28a9d2b-47a6-4d55-bc6b-ef776f4464c9",
      "name": "Session State Manager",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -3740,
        350
      ]
    },
    {
      "parameters": {
        "jsCode": "// Course Completion Handler\nconst sessionId = $json.sessionId;\nconst session = $json.sessionState;\n\n// Calculate final statistics\nconst totalConcepts = session.completedConcepts.length;\nconst coreConceptsCompleted = session.completedConcepts.filter(id => \n  typeof id === 'number'\n).length;\nconst dynamicConceptsCompleted = totalConcepts - coreConceptsCompleted;\nconst skippedConcepts = session.skippedConcepts?.length || 0;\n\n// Prepare completion response\nconst responseData = {\n  sessionId,\n  toolType: 'course_complete',\n  courseComplete: true,\n  toolData: {\n    title: 'Congratulations! Course Complete',\n    summary: `You've successfully completed all ${totalConcepts} concepts in the course.`,\n    statistics: {\n  coreConceptsCompleted,\n  dynamicConceptsAdded: dynamicConceptsCompleted,\n  conceptsSkipped: skippedConcepts,\n  totalInteractions: session.interactionHistory.length,\n  completionBreakdown: {\n    mastered: Object.values(session.completionMetadata || {})\n      .filter(m => m.completionType === 'mastered').length,\n    adequate: Object.values(session.completionMetadata || {})\n      .filter(m => m.completionType === 'adequate').length,\n    struggled: Object.values(session.completionMetadata || {})\n      .filter(m => m.completionType === 'struggled').length,\n    skipped: skippedConcepts\n  }\n},\n    message: 'Great job completing the AI Native Product Manager course!'\n  },\n  waitingForInput: false\n};\n\nreturn {\n  responseData\n};"
      },
      "id": "aa6fd26e-4342-4ee8-a8bd-caac1935ac77",
      "name": "Course Completion",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        0,
        0
      ]
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// Fix for Concept Card Handler\n// Location: \"Concept Card Handler\" node\n\nconst concept = $json.currentConcept;\nconst sessionId = $json.sessionId;\nconst learnerNote = $json.learnerInput?.note;\n\n// Get session from global\nconst session = $getWorkflowStaticData('global').sessions[sessionId];\n\n// UPDATE STATE MACHINE\n// This handler only runs when first showing the concept card\nsession.stateMachine.previousState = session.stateMachine.currentState;\nsession.stateMachine.currentState = 'concept_card_shown';\nsession.stateMachine.stateHistory.push({\n  from: session.stateMachine.previousState,\n  to: 'concept_card_shown',\n  action: 'show_concept_card',\n  timestamp: new Date().toISOString(),\n  conceptId: concept.id,\n  conceptTitle: concept.title\n});\n\n// Update concept tools tracking\nif (!session.currentConceptTools.includes('concept_card')) {\n  session.currentConceptTools.push('concept_card');\n}\nsession.lastToolUsed = 'concept_card';\n\n// Save updated state\n$getWorkflowStaticData('global').sessions[sessionId] = session;\n\nconst responseData = {\n  sessionId,\n  toolType: 'concept_card',\n  conceptProgress: {\n    current: session.completedConcepts.length + 1,\n    total: session.remainingCoreConcepts.length + \n           session.completedConcepts.length + \n           session.insertedConcepts.length\n  },\n  toolData: {\n    title: concept.title,\n    summary: concept.summary,\n    expertTips: concept.expertTips,\n    canSubmitNote: true\n  },\n  waitingForInput: true,\n  inputType: 'note',\n  message: 'Read through the concept and feel free to add any notes or questions.'\n};\n\n// Just return the response\nreturn {\n  ...($json),\n  responseData,\n  sessionId,\n  learnerProfile: $json.learnerProfile\n};"
      },
      "id": "54256739-0559-4806-a0e6-fdf2f73866fd",
      "name": "Concept Card Handler",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -660,
        1075
      ]
    },
    {
      "parameters": {
        "jsCode": "// Fix for Assessment Handler\n// Location: \"Assessment Handler\" node\n\nconst concept = $json.currentConcept;\nconst sessionId = $json.sessionId;\nconst learnerAnswer = $json.learnerInput?.answer;\nconst session = $json.sessionState;\n\n// UPDATE STATE MACHINE\n// This handler runs when showing assessment - always transitions to 'assessment_shown'\nsession.stateMachine.previousState = session.stateMachine.currentState;\nsession.stateMachine.currentState = 'assessment_shown';\nsession.stateMachine.stateHistory.push({\n  from: session.stateMachine.previousState,\n  to: 'assessment_shown',\n  action: 'show_assessment',\n  timestamp: new Date().toISOString(),\n  conceptId: concept.id,\n  conceptTitle: concept.title\n});\n\n// Update session state\nif (!session.currentConceptTools.includes('assessment')) {\n  session.currentConceptTools.push('assessment');\n}\nsession.lastToolUsed = 'assessment';\n\n// Save updated state\n$getWorkflowStaticData('global').sessions[sessionId] = session;\n\nconst responseData = {\n  sessionId,\n  toolType: 'assessment',\n  conceptProgress: {\n    current: session.completedConcepts.length + 1,\n    total: session.remainingCoreConcepts.length + \n           session.completedConcepts.length + \n           session.insertedConcepts.length\n  },\n  toolData: {\n    question: concept.assessmentQuestion,\n    conceptTitle: concept.title\n  },\n  waitingForInput: !learnerAnswer,\n  inputType: 'answer',\n  message: 'Answer the question to check your understanding.'\n};\n\n// If we have an answer, we need to grade it\nif (learnerAnswer) {\n  return {\n    ...($json),\n    needsGrading: true,\n    learnerAnswer,\n    responseData\n  };\n}\n\nreturn {\n  ...($json),\n  needsGrading: false,\n  responseData\n};"
      },
      "id": "2a55c1e2-d092-40e6-a2d6-f2c196a4f0a7",
      "name": "Assessment Handler",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -660,
        1275
      ]
    },
    {
      "parameters": {
        "jsCode": "// Process Combined Grading and Knowledge Analysis\nconst result = JSON.parse($json.choices[0].message.content);\n\n// Get data from the pipeline (from Grade Assessment AI Call)\nconst sessionId = $('Generate Assessment Grading Prompt').first().json.originalData.sessionId;\nconst originalData = $('Generate Assessment Grading Prompt').first().json.originalData;\n\n// Get session directly from global\nconst session = $getWorkflowStaticData('global').sessions[sessionId];\n\n// Update assessment score\nsession.lastAssessmentScore = result.score;\n\n// Update knowledge state from the combined analysis\nif (result.knowledgeUpdate) {\n  session.knowledgeStrengths = result.knowledgeUpdate.updatedStrengths || [];\n  session.knowledgeGaps = result.knowledgeUpdate.updatedGaps || [];\n  \n  // Track knowledge evolution\n  if (!session.knowledgeEvolution) {\n    session.knowledgeEvolution = [];\n  }\n  \n  session.knowledgeEvolution.push({\n    timestamp: new Date().toISOString(),\n    concept: session.currentConcept.title,\n    conceptId: session.currentConcept.id,\n    isDynamic: session.currentConcept.isDynamic || false,\n    score: result.score,\n    strengths: result.knowledgeUpdate.updatedStrengths,\n    gaps: result.knowledgeUpdate.updatedGaps,\n    reasoning: result.knowledgeUpdate.reasoning\n  });\n}\n\n// UPDATE STATE MACHINE\nsession.stateMachine.previousState = session.stateMachine.currentState;\nsession.stateMachine.currentState = 'assessment_graded';\nsession.stateMachine.stateHistory.push({\n  from: 'assessment_submitted',\n  to: 'assessment_graded',\n  action: 'grading_complete',\n  timestamp: new Date().toISOString(),\n  orchestrator: 'core',\n  data: { score: result.score }\n});\n\n// Handle dynamic concept gap resolution\nif (session.currentConcept.isDynamic && result.score >= 3 && session.currentConcept.targetedGaps) {\n  session.knowledgeGaps = session.knowledgeGaps.filter(\n    gap => !session.currentConcept.targetedGaps.includes(gap)\n  );\n}\n\n// Track assessment history\nif (!session.assessmentHistory) {\n  session.assessmentHistory = [];\n}\n\nsession.assessmentHistory.push({\n  concept: session.currentConcept.title,\n  conceptId: session.currentConcept.id,\n  score: result.score,\n  timestamp: new Date().toISOString()\n});\n\n// Save updated state back to global\n$getWorkflowStaticData('global').sessions[sessionId] = session;\n\n// Build the response data structure\nconst responseData = {\n  sessionId,\n  toolType: 'assessment',\n  conceptProgress: {\n    current: session.completedConcepts.length + 1,\n    total: session.remainingCoreConcepts.length + \n           session.completedConcepts.length + \n           session.insertedConcepts.length\n  },\n  toolData: {\n    question: session.currentConcept?.assessmentQuestion,\n    conceptTitle: session.currentConcept?.title,\n    gradingResult: {\n      score: result.score,\n      feedback: result.feedback,\n      understood: result.understood\n    }\n  },\n  waitingForInput: false,\n  nextAction: result.score >= 4 ? \n    'Excellent work! Click Next to continue.' : \n    result.score >= 3 ?\n    'Good understanding! Click Next to continue.' :\n    'Let\\'s reinforce this concept. Click Next to continue.'\n};\n\n// Pass all necessary data forward in the pipeline\nreturn {\n  ...originalData, // Spread the original data\n  gradingResult: result,\n  responseData,\n  sessionId,\n  learnerProfile: originalData.learnerProfile\n};"
      },
      "id": "2a7f4f29-fd10-48f2-b75d-4567c928cfe0",
      "name": "Process Grading",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1760,
        450
      ]
    },
    {
      "parameters": {
        "jsCode": "// Simple Fix for Prompt Exercise Handler\n// This checks session for any previously generated enhanced task\n\nconst concept = $json.currentConcept;\nconst sessionId = $json.sessionId;\nconst session = $getWorkflowStaticData('global').sessions[sessionId];\n\n// Check multiple sources for enhanced task data\nconst enhancedTask = $json.enhancedPromptTask || \n                    session.currentPromptExercise || \n                    null;\n\n// UPDATE STATE MACHINE\nsession.stateMachine.previousState = session.stateMachine.currentState;\nsession.stateMachine.currentState = 'prompt_exercise_shown';\nsession.stateMachine.stateHistory.push({\n  from: session.stateMachine.previousState,\n  to: 'prompt_exercise_shown',\n  action: 'show_prompt_exercise',\n  timestamp: new Date().toISOString(),\n  conceptId: concept.id,\n  conceptTitle: concept.title\n});\n\n// Update session state\nif (!session.currentConceptTools.includes('prompt_exercise')) {\n  session.currentConceptTools.push('prompt_exercise');\n}\nsession.lastToolUsed = 'prompt_exercise';\n\n// Check if this is the SECOND time showing prompt exercise\n// (after enhancement was generated)\nconst isEnhancedDisplay = session.promptExerciseShowCount > 0;\n\n// Increment show count\nsession.promptExerciseShowCount = (session.promptExerciseShowCount || 0) + 1;\n\n// Save updated state\n$getWorkflowStaticData('global').sessions[sessionId] = session;\n\n// Use enhanced task if available, otherwise show basic\nconst taskToShow = enhancedTask?.task || \n                  (concept.promptTask || 'Generate a prompt for this concept');\n\nconst responseData = {\n  sessionId,\n  toolType: 'prompt_exercise',\n  conceptProgress: {\n    current: session.completedConcepts.length + 1,\n    total: session.remainingCoreConcepts.length + \n           session.completedConcepts.length + \n           session.insertedConcepts.length\n  },\n  toolData: {\n    task: taskToShow,\n    context: enhancedTask?.context || null,\n    hints: enhancedTask?.hints || [],\n    conceptTitle: concept.title,\n    difficulty: enhancedTask?.difficulty || 'intermediate'\n  },\n  waitingForInput: true,\n  inputType: 'prompt',\n  message: 'Practice your prompt engineering skills with this task.'\n};\n\n// Return the response\nreturn {\n  ...($json),\n  responseData,\n  sessionId,\n  learnerProfile: $json.learnerProfile\n};"
      },
      "id": "ae9f1a2b-60b1-4f22-909d-1ab51c87010d",
      "name": "Prompt Exercise Handler",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1320,
        1475
      ]
    },
    {
      "parameters": {
        "numberInputs": 3
      },
      "id": "d42a720e-a909-4bde-ad75-4e1760793faa",
      "name": "Merge Responses",
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3,
      "position": [
        220,
        200
      ]
    },
    {
      "parameters": {
        "options": {}
      },
      "id": "bfd6fc8e-33ac-4795-9036-aeae71a30173",
      "name": "Webhook Response",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.1,
      "position": [
        660,
        200
      ]
    },
    {
      "parameters": {
        "path": "reset-session",
        "responseMode": "responseNode",
        "options": {}
      },
      "id": "c3aceff9-8ba6-4058-957c-d92b81a3daef",
      "name": "Reset Session Webhook",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 1.1,
      "position": [
        -4400,
        1735
      ],
      "webhookId": "594653ea-5a3e-4e99-9a1d-c2ecdf0f5c56"
    },
    {
      "parameters": {
        "jsCode": "// Reset Session\nconst sessionId = $json.query?.sessionId || 'default-session';\n\n// Clear session data\nconst sessionState = $getWorkflowStaticData('global');\nif (sessionState.sessions && sessionState.sessions[sessionId]) {\n  delete sessionState.sessions[sessionId];\n}\n\nreturn {\n  success: true,\n  message: `Session ${sessionId} has been reset`,\n  sessionId\n};"
      },
      "id": "a788c2e3-36bb-421b-8731-08e8ba832ac0",
      "name": "Reset Session",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -4180,
        1735
      ]
    },
    {
      "parameters": {
        "options": {}
      },
      "id": "593bb970-f738-4e13-a49f-d197f720b8ff",
      "name": "Reset Response",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.1,
      "position": [
        -3960,
        1735
      ]
    },
    {
      "parameters": {
        "jsCode": "// Extract webhook data from the first item in the array\nconst webhookData = $input.first().json.body;\n\n// Add course data\nreturn {\n  sessionId: webhookData.sessionId,\n  userName: webhookData.userName,\n  action: webhookData.action,\n  learnerInput: webhookData.learnerInput,\n  courseTopic: \"How to Become an AI Native Product Manager\",\n  learnerProfile: {\n    role: \"Product Manager\",\n    company: \"TechCorp\",\n    skills: [\"Agile\", \"User Research\", \"Basic Python\"]\n  },\n  \"coreConcepts\": [\n    {\n      \"id\": 1,\n      \"title\": \"Prompt Engineering Essentials\",\n      \"summary\": \"Prompt engineering is the skill of writing clear, structured inputs that guide AI tools to produce high-quality, relevant outputs. It’s not just about asking a question—it’s about communicating with precision, providing context, and defining the role, tone, or format you want. This module helps project managers master this foundational skill so they can make AI tools like ChatGPT work for them across a range of tasks. Good prompting starts by defining the outcome: Are you asking for a summary, a message, a task list, or a risk forecast? Then, you refine the input by adding necessary context—what project, what audience, what constraints. Including tone, format (like bullet points or CSV), and role (e.g., 'you are a project coordinator') helps tailor results. This level of clarity minimizes ambiguity and reduces the need for follow-up corrections. Learners will also explore techniques like using delimiters for structured inputs, applying personas, and iterating based on AI outputs. The goal is to reduce guesswork and enable precise, repeatable results—whether drafting communications, outlining plans, or analyzing decisions. Prompting is a superpower for modern PMs: it lets you turn AI into a strategic assistant. This skill transforms vague requests into clear, actionable outputs that can immediately feed into your project tools and workflows.\",\n      \"expertTips\": [\n        \"Use personas to shift tone and tailor responses.\",\n        \"Split complex tasks into subtasks to avoid token limit issues and improve output quality.\",\n        \"Use triple quotes or backticks to clearly delimit long context or code.\"\n      ],\n      \"assessmentQuestion\": \"What is the most important technique to apply when writing a prompt to ChatGPT for best results?\",\n      \"correctAnswer\": \"Include detailed instructions and context for the task\",\n      \"shouldHavePromptTask\": true\n    },\n        {\n      \"id\": 2,\n      \"title\": \"Project Management AI Foundations\",\n      \"summary\": \"To unlock AI’s full potential as a project manager, you need to understand where and how it integrates into the project lifecycle. AI tools are particularly strong at augmenting core PM activities such as scheduling, forecasting, risk identification, stakeholder communication, and report generation. This module introduces foundational AI use cases across project stages and helps learners map tools to workflows. For example, task decomposition and milestone creation can be accelerated by tools like ChatGPT when paired with a strong prompt. Risk modeling can benefit from AI simulations that explore different 'what-if' scenarios. Communication updates and meeting summaries can be generated more efficiently, freeing PMs to focus on strategy. Learners will gain clarity on the difference between automation (repetitive task execution) and augmentation (strategic insight generation), and how AI supports each. AI foundations also include an understanding of tool categories—chat-based assistants, integrated copilots in platforms like Microsoft Teams or Notion, and no-code AI builders. Once you understand where these tools fit, you can begin evaluating your own workflows for inefficiencies and AI opportunities. This knowledge also helps PMs articulate the ROI of AI to stakeholders—making it easier to champion new tools within the organization.\",\n      \"expertTips\": [\n        \"Ask ChatGPT to ask you questions when you're missing context.\",\n        \"Enable custom instructions for faster, context-aware prompt responses across recurring tasks.\"\n      ],\n      \"assessmentQuestion\": \"Which of the following is the best example of using AI to augment project management activities?\",\n      \"correctAnswer\": \"Using ChatGPT to identify risks in a draft project plan and summarize key concerns\",\n      \"shouldHavePromptTask\": true\n    },\n    {\n      \"id\": 3,\n      \"title\": \"Smarter Planning with AI\",\n      \"summary\": \"AI excels at turning goals into structured plans—when guided correctly. In this module, learners will explore how to use AI to generate project roadmaps, create task hierarchies, define dependencies, and sequence milestones. Planning with AI begins by inputting a clear objective or deliverable and adding constraints like deadlines, resources, or blockers. The AI can then propose a draft plan, which the project manager reviews and refines. The real power lies in iteration—adjusting prompts to tweak scope, task order, or effort level. AI also supports reverse planning, where you start from a fixed deadline and ask it to work backwards. Project managers will also learn how to test and validate AI-generated plans: Does the dependency order make sense? Are key milestones too dense or too sparse? Is effort distribution realistic? Learners will practice identifying flaws and giving corrective instructions, reinforcing that AI is a collaborator, not a replacement. The module encourages hands-on testing with tools like ChatGPT or Copilot embedded in planning tools. Learners who complete this module will be able to use AI to jumpstart planning sessions, unblock ambiguity, and refine their timelines with greater speed and clarity.\",\n      \"expertTips\": [],\n      \"assessmentQuestion\": \"When reviewing an AI-generated project plan, what is a good follow-up action?\",\n      \"correctAnswer\": \"Check for inaccurate task dependencies and revise the prompt to fix the logic\",\n      \"shouldHavePromptTask\": true\n    }\n  ]\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -3960,
        350
      ],
      "id": "f9cfaed0-e502-45ff-bc3a-97e4063b74bc",
      "name": "Init Course Data"
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// Extract Response Data\nconst responseData = $json.responseData;\n\nif (!responseData) {\n  throw new Error('No responseData found in input');\n}\n\nreturn responseData;"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        440,
        200
      ],
      "id": "ddb6f37f-de10-4755-bcb2-322171d87022",
      "name": "Limit Data"
    },
    {
      "parameters": {},
      "type": "n8n-nodes-base.manualTrigger",
      "typeVersion": 1,
      "position": [
        -4400,
        250
      ],
      "id": "69443795-3e8d-4568-82d9-75c0c4d977a8",
      "name": "When clicking 'Test workflow'"
    },
    {
      "parameters": {
        "mode": "raw",
        "jsonOutput": "{\n  \"body\": {\n    \"sessionId\": \"manual_session\",\n    \"userName\": \"Mohammed Ali\",\n    \"action\": \"next\",\n    \"learnerInput\": {}\n  }\n}",
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        -4180,
        250
      ],
      "id": "18dc64d6-1a02-4507-b3b8-0f7dc64c5c90",
      "name": "Edit Fields"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://api.openai.com/v1/chat/completions",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "openAiApi",
        "sendBody": true,
        "bodyParameters": {
          "parameters": [
            {
              "name": "model",
              "value": "={{ $json.model }}"
            },
            {
              "name": "messages",
              "value": "={{ $json.messages }}"
            },
            {
              "name": "temperature",
              "value": "={{ $json.temperature }}"
            },
            {
              "name": "max_tokens",
              "value": "={{ $json.max_tokens }}"
            },
            {
              "name": "response_format",
              "value": "={{ $json.response_format }}"
            }
          ]
        },
        "options": {}
      },
      "id": "161de99a-7b50-4f82-8fad-858b037b8088",
      "name": "Grade Assessment AI Call",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -1980,
        450
      ],
      "credentials": {
        "openAiApi": {
          "id": "UFaW72U0IV5U0Ec5",
          "name": "OpenAi account"
        }
      }
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// Generate Concept Prompt - Prepares prompt for creating new adaptive concepts\nconst messages = [\n  {\n    role: \"system\",\n    content: \"Generate a new mini-concept to address a specific learning gap. The concept MUST directly target the identified gap, and the assessment question MUST verify the learner understands the gap area. Focus on building a bridge from their current understanding to the correct concept.\"\n  },\n  {\n    role: \"user\", \n    content: `Context:\n- Main Topic: ${$json.courseTopic}\n- Current Concept: ${$json.currentConcept.title}\n- Knowledge Gap: ${$json.orchestratorDecision.conceptNeeded.reason}\n- Specific Gap to Address: ${$json.sessionState.knowledgeGaps?.[0] || $json.orchestratorDecision.conceptNeeded.focus}\n- Learner Profile: ${$json.learnerProfile.role} at ${$json.learnerProfile.company}\n\nThe learner scored ${$json.sessionState.lastAssessmentScore}/5 and showed confusion about: \"${$json.sessionState.knowledgeGaps?.[0] || 'the core concept'}\"\n\nCreate a focused concept that DIRECTLY addresses this specific gap: \"${$json.orchestratorDecision.conceptNeeded.reason}\"\n\nThe assessment question MUST test whether the learner understands: ${$json.sessionState.knowledgeGaps?.[0] || $json.orchestratorDecision.conceptNeeded.focus}\n\nReturn JSON:\n{\n  \"title\": \"Clear, specific title\",\n  \"summary\": \"500 word overview\",\n  \"expertTips\": [\"2-3 practical tips\"],\n  \"assessmentQuestion\": \"Targeted question to verify understanding\",\n  \"correctAnswer\": \"Brief correct answer\"\n}`\n  }\n];\n\nreturn {\n  messages,\n  model: \"gpt-4o\",\n  temperature: 0.7,\n  max_tokens: 1000,\n  response_format: { type: \"json_object\" },\n  // Pass through ALL the original data\n  originalData: $json\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -2200,
        1371
      ],
      "id": "be6c4756-8d39-4edd-a4d1-ac8a09a1d37b",
      "name": "Generate New Concept Prompt"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://api.openai.com/v1/chat/completions",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "openAiApi",
        "sendBody": true,
        "bodyParameters": {
          "parameters": [
            {
              "name": "model",
              "value": "={{ $json.model }}"
            },
            {
              "name": "messages",
              "value": "={{ $json.messages }}"
            },
            {
              "name": "temperature",
              "value": "={{ $json.temperature }}"
            },
            {
              "name": "max_tokens",
              "value": "={{ $json.max_tokens }}"
            },
            {
              "name": "response_format",
              "value": "={{ $json.response_format }}"
            }
          ]
        },
        "options": {}
      },
      "id": "05c56191-1687-4042-9daf-55e6a059bdc6",
      "name": "Generate New Concept AI Call",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -1980,
        1371
      ],
      "credentials": {
        "openAiApi": {
          "id": "UFaW72U0IV5U0Ec5",
          "name": "OpenAi account"
        }
      }
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// Enhanced Core Orchestrator - Handles deterministic flow logic\n// This replaces the existing Core Orchestrator node code\n\nconst sessionId = $json.sessionId;\nconst action = $json.action;\nconst learnerInput = $json.learnerInput;\n\n// Read state directly from global\nconst session = $getWorkflowStaticData('global').sessions[sessionId];\nif (!session) {\n  throw new Error(`Session ${sessionId} not found`);\n}\n\n// Get current state\nconst currentState = session.stateMachine.currentState;\nconst lastToolUsed = session.lastToolUsed;\nconst currentConcept = session.currentConcept;\nconst toolsUsed = session.currentConceptTools || [];\n\n// DETERMINISTIC FLOW LOGIC - This is the \"happy path\"\nfunction determineDefaultNextAction(session, action) {\n  const toolsUsed = session.currentConceptTools || [];\n  const hasAssessmentScore = session.lastAssessmentScore !== null;\n  const assessmentScore = session.lastAssessmentScore || 0;\n  \n  // Special case: Starting the course\n  if (action === 'start' && currentState === 'uninitialized') {\n    return {\n      action: 'show_welcome',\n      reason: 'Starting course'\n    };\n  }\n  \n  // Special case: Moving from welcome\n  if (action === 'next' && currentState === 'welcome') {\n    return {\n      action: 'load_first_concept',\n      reason: 'Moving from welcome to first concept'\n    };\n  }\n  \n  // No current concept - need to load one\n  if (!session.currentConcept) {\n    if (session.remainingCoreConcepts.length > 0) {\n      return {\n        action: 'load_next_concept',\n        reason: 'No current concept, loading next from queue'\n      };\n    } else {\n      return {\n        action: 'course_complete',\n        reason: 'No more concepts to learn'\n      };\n    }\n  }\n  \n  // MAIN FLOW LOGIC - For concepts in progress\n  \n  // Step 1: Always start with concept_card\n  if (!toolsUsed.includes('concept_card')) {\n    return {\n      action: 'concept_card',\n      reason: 'Every concept must start with concept card',\n      isRequired: true\n    };\n  }\n  \n  // Step 2: After concept_card, do assessment\n  if (toolsUsed.includes('concept_card') && !toolsUsed.includes('assessment')) {\n    return {\n      action: 'assessment',\n      reason: 'Assessment follows concept card',\n      isRequired: true,\n      canSkip: true // But only with explicit learner request\n    };\n  }\n  \n  // Step 3: After assessment, decide based on score\n  if (toolsUsed.includes('assessment') && hasAssessmentScore) {\n    // Check if we should do prompt exercise\n    const shouldDoPromptExercise = \n      assessmentScore >= 3 && \n      session.currentConcept?.shouldHavePromptTask && \n      !toolsUsed.includes('prompt_exercise');\n    \n    if (shouldDoPromptExercise) {\n      return {\n        action: 'prompt_exercise',\n        reason: `Good assessment score (${assessmentScore}/5) and prompt task available`,\n        isOptional: true // Adaptive orchestrator can override this\n      };\n    }\n    \n    // Low score might need remediation, but let adaptive orchestrator decide\n    if (assessmentScore < 3) {\n      return {\n        action: 'concept_complete',\n        reason: `Low score (${assessmentScore}/5) - adaptive orchestrator may insert remedial concept`,\n        suggestRemediation: true\n      };\n    }\n    \n    // Otherwise, concept is complete\n    return {\n      action: 'concept_complete',\n      reason: 'All required tools completed'\n    };\n  }\n  \n  // Step 4: After prompt exercise, complete the concept\n  if (toolsUsed.includes('prompt_exercise')) {\n    return {\n      action: 'concept_complete',\n      reason: 'Prompt exercise completed'\n    };\n  }\n  \n  // Fallback\n  return {\n    action: 'concept_complete',\n    reason: 'Default fallback action'\n  };\n}\n\n// Check if course is complete\nconst allConceptsCompleted = session.remainingCoreConcepts.length === 0;\nconst noPendingDynamicConcepts = session.insertedConcepts.every(\n  conceptId => session.completedConcepts.includes(conceptId)\n);\nconst courseComplete = !currentConcept && allConceptsCompleted && noPendingDynamicConcepts;\n\nconsole.log(`Core Orchestrator: action=${action}, state=${currentState}, concept=${currentConcept?.title}`);\n\n// Initialize routing variables\nlet routeTo = null;\nlet updateState = null;\nlet defaultNextAction = null;\n\n// ROUTING LOGIC - Handle special cases and state transitions\nif (courseComplete) {\n  routeTo = 'show_completion';\n  updateState = 'course_complete';\n}\n// Start of course\nelse if (action === 'start' && currentState === 'uninitialized') {\n  routeTo = 'show_welcome';\n  updateState = 'welcome';\n}\n// Moving from welcome to first concept\nelse if (action === 'next' && currentState === 'welcome') {\n  // Get the first concept and set it as current\n  let nextConcept = null;\n  if (session.remainingCoreConcepts.length > 0) {\n    const nextId = session.remainingCoreConcepts[0];\n    nextConcept = $json.coreConcepts.find(c => c.id === nextId);\n    \n    if (nextConcept) {\n      // Remove from remaining WHEN WE START IT\n      session.remainingCoreConcepts = session.remainingCoreConcepts.filter(id => id !== nextId);\n      \n      // Mark it as core concept\n      nextConcept.isCore = true;\n      \n      // Set as current\n      session.currentConcept = nextConcept;\n      session.currentConceptTools = [];\n      session.lastAssessmentScore = null;\n      \n      // Determine default next action for this new concept\n      defaultNextAction = determineDefaultNextAction(session, action);\n      \n      // Route to Adaptive Orchestrator with suggestion\n      routeTo = 'adaptive_orchestrator';\n    }\n  }\n}\n// Handle submission of assessment answer\nelse if (action === 'submit_response' && lastToolUsed === 'assessment' && learnerInput?.answer) {\n  // Record the interaction\n  session.interactionHistory.push({\n    concept: session.currentConcept?.title,\n    tool: 'assessment',\n    input: learnerInput,\n    timestamp: new Date().toISOString()\n  });\n  \n  // Always go through adaptive orchestrator if there's a note\n  if (learnerInput?.note) {\n    session.pendingAssessment = {\n      answer: learnerInput.answer,\n      note: learnerInput.note,\n      question: session.currentConcept?.assessmentQuestion\n    };\n    \n    // Get default action (which would be to grade)\n    defaultNextAction = {\n      action: 'grade_assessment',\n      reason: 'Assessment submitted, default is to grade',\n      hasLearnerNote: true\n    };\n    \n    routeTo = 'adaptive_orchestrator';\n    updateState = 'assessment_with_note_pending';\n  } else {\n    // No note - proceed with normal grading\n    routeTo = 'grade_assessment';\n    updateState = 'assessment_submitted';\n  }\n}\n// All other cases - determine default and let adaptive orchestrator decide\nelse {\n  // Calculate the default next action based on current state\n  defaultNextAction = determineDefaultNextAction(session, action);\n  \n  // Special handling for specific actions\n  if (action === 'submit_response') {\n    // Record interactions\n    session.interactionHistory.push({\n      concept: session.currentConcept?.title,\n      tool: lastToolUsed,\n      input: learnerInput,\n      timestamp: new Date().toISOString()\n    });\n    \n    // Track questions/notes\n    if (learnerInput?.note) {\n      session.recentQuestions.push(learnerInput.note);\n      if (session.recentQuestions.length > 5) {\n        session.recentQuestions.shift();\n      }\n    }\n  }\n  \n  // Always route through adaptive orchestrator for intelligent decisions\n  routeTo = 'adaptive_orchestrator';\n}\n\n// Update state machine if needed\nif (updateState) {\n  session.stateMachine.previousState = currentState;\n  session.stateMachine.currentState = updateState;\n  session.stateMachine.stateHistory.push({\n    from: currentState,\n    to: updateState,\n    action: action,\n    timestamp: new Date().toISOString(),\n    orchestrator: 'core'\n  });\n}\n\n// Save back to global\n$getWorkflowStaticData('global').sessions[sessionId] = session;\n\n// Build comprehensive context for adaptive orchestrator\nconst orchestratorContext = {\n  defaultNextAction: defaultNextAction,\n  currentProgress: {\n    toolsCompleted: session.currentConceptTools,\n    hasAssessment: session.currentConceptTools.includes('assessment'),\n    assessmentScore: session.lastAssessmentScore,\n    hasPromptExercise: session.currentConceptTools.includes('prompt_exercise')\n  },\n  learnerContext: {\n    hasNote: !!learnerInput?.note,\n    noteContent: learnerInput?.note,\n    recentQuestions: session.recentQuestions,\n    knowledgeGaps: session.knowledgeGaps,\n    knowledgeStrengths: session.knowledgeStrengths\n  },\n  conceptContext: {\n    currentConcept: session.currentConcept,\n    isCore: session.currentConcept?.isCore,\n    isDynamic: session.currentConcept?.isDynamic,\n    targetedGaps: session.currentConcept?.targetedGaps\n  }\n};\n\n// Pass through current concept if it exists\nconst outputData = {\n  sessionId,\n  action,\n  learnerInput,\n  courseTopic: $json.courseTopic,\n  learnerProfile: $json.learnerProfile,\n  coreConcepts: $json.coreConcepts,\n  userName: $json.userName,\n  routeTo: routeTo,\n  courseComplete: courseComplete,\n  // IMPORTANT: Pass the default next action and context\n  defaultNextAction: defaultNextAction,\n  orchestratorContext: orchestratorContext\n};\n\n// Include current concept if we have one\nif (session.currentConcept) {\n  outputData.currentConcept = session.currentConcept;\n}\n\n// Include session state for debugging\noutputData.sessionState = {\n  remainingCoreConcepts: session.remainingCoreConcepts,\n  completedConcepts: session.completedConcepts,\n  currentConceptId: session.currentConcept?.id,\n  stateMachine: session.stateMachine\n};\n\nreturn outputData;"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -3520,
        350
      ],
      "id": "85da8ca4-5e62-49bf-8073-ca187e12d49a",
      "name": "Core Orchestrator"
    },
    {
      "parameters": {
        "rules": {
          "values": [
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "id": "51295a96-00b1-497c-8a67-dd809c86da1b",
                    "leftValue": "{{ $json.routeTo }}",
                    "rightValue": "show_completion",
                    "operator": {
                      "type": "string",
                      "operation": "equals",
                      "name": "filter.operator.equals"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "courseComplete"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "leftValue": "={{ $json.routeTo }}",
                    "rightValue": "show_welcome",
                    "operator": {
                      "type": "string",
                      "operation": "equals"
                    },
                    "id": "8691f62e-4d5e-43ff-9a26-5d7b4c81ee13"
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "welcome"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "id": "c07fc040-2d20-447e-b1df-286099b45a6a",
                    "leftValue": "={{ $json.routeTo }}",
                    "rightValue": "grade_assessment",
                    "operator": {
                      "type": "string",
                      "operation": "equals",
                      "name": "filter.operator.equals"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "gradeAssessment"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "id": "2c2549a8-034c-4335-8948-55e84333d21e",
                    "leftValue": "={{ $json.routeTo }}",
                    "rightValue": "evaluate_prompt",
                    "operator": {
                      "type": "string",
                      "operation": "equals",
                      "name": "filter.operator.equals"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "evaluatePrompt"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "id": "4b5e3875-e16a-4855-9817-960a1cce95ab",
                    "leftValue": "={{ $json.routeTo }}",
                    "rightValue": "adaptive_orchestrator",
                    "operator": {
                      "type": "string",
                      "operation": "equals",
                      "name": "filter.operator.equals"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "toAdaptiveOrchestrator"
            }
          ]
        },
        "options": {
          "fallbackOutput": "extra",
          "renameFallbackOutput": "adaptive_orchestrator"
        }
      },
      "type": "n8n-nodes-base.switch",
      "typeVersion": 3.2,
      "position": [
        -3300,
        287
      ],
      "id": "d6c7226d-a101-4894-9460-53a70e297a40",
      "name": "Core Router"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://api.openai.com/v1/chat/completions",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "openAiApi",
        "sendBody": true,
        "bodyParameters": {
          "parameters": [
            {
              "name": "model",
              "value": "={{ $json.model }}"
            },
            {
              "name": "messages",
              "value": "={{ $json.messages }}"
            },
            {
              "name": "temperature",
              "value": "={{ $json.temperature }}"
            },
            {
              "name": "max_tokens",
              "value": "={{ $json.max_tokens }}"
            },
            {
              "name": "response_format",
              "value": "={{ $json.response_format }}"
            }
          ]
        },
        "options": {}
      },
      "id": "d533057c-0297-473b-b4b9-baa69afa73d1",
      "name": "Adaptive Orchestrator AI Call",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -2860,
        875
      ],
      "credentials": {
        "openAiApi": {
          "id": "UFaW72U0IV5U0Ec5",
          "name": "OpenAi account"
        }
      }
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// Process Adaptive Orchestrator Decision - UPDATED FOR NEW FORMAT\nconst orchestratorDecision = JSON.parse($json.choices[0].message.content);\n\nconst sessionId = $('Generate Adaptive Orchestrator Router Prompt').first().json.originalData.sessionId;\nconst originalData = $('Generate Adaptive Orchestrator Router Prompt').first().json.originalData;\n\n// Get session directly from global\nconst session = $getWorkflowStaticData('global').sessions[sessionId];\n\n// Initialize tracking if needed\nif (!session.gapAttempts) session.gapAttempts = {};\nif (!session.deferredGaps) session.deferredGaps = [];\nif (!session.skippedConcepts) session.skippedConcepts = [];\n\n// LOG DECISION TRACKING - New addition to track override patterns\nconsole.log(`Orchestrator Decision: ${orchestratorDecision.nextAction} (Following default: ${orchestratorDecision.followingDefault})`);\nif (!orchestratorDecision.followingDefault) {\n  console.log(`Override reason: ${orchestratorDecision.overrideReason}`);\n}\n\n// Track override patterns for analysis (optional but useful)\nif (!session.orchestratorOverrides) session.orchestratorOverrides = [];\nif (!orchestratorDecision.followingDefault) {\n  session.orchestratorOverrides.push({\n    timestamp: new Date().toISOString(),\n    defaultAction: originalData.defaultNextAction?.action,\n    overrideAction: orchestratorDecision.nextAction,\n    reason: orchestratorDecision.overrideReason,\n    noteAnalysis: orchestratorDecision.noteAnalysis\n  });\n}\n\n// CRITICAL: Load next concept if we don't have one and need to show concept_card\nif (!session.currentConcept && orchestratorDecision.nextAction === 'concept_card') {\n  console.log('Adaptive Orchestrator: No current concept, loading next...');\n  \n  if (session.remainingCoreConcepts.length > 0) {\n    const nextId = session.remainingCoreConcepts[0];\n    const nextConcept = originalData.coreConcepts.find(c => c.id === nextId);\n    \n    if (nextConcept) {\n      // Remove from remaining\n      session.remainingCoreConcepts = session.remainingCoreConcepts.filter(id => id !== nextId);\n      \n      // Mark it as core concept\n      nextConcept.isCore = true;\n      \n      // Set as current\n      session.currentConcept = nextConcept;\n      session.currentConceptTools = [];\n      session.lastAssessmentScore = null;\n      session.knowledgeGaps = [];\n      session.promptExerciseShowCount = 0; // Reset prompt exercise counter\n      \n      console.log(`Loaded concept ${nextConcept.id}: ${nextConcept.title}`);\n      \n      // Update state machine\n      session.stateMachine.previousState = session.stateMachine.currentState;\n      session.stateMachine.currentState = 'concept_started';\n      session.stateMachine.stateHistory.push({\n        from: session.stateMachine.previousState,\n        to: 'concept_started',\n        action: 'load_next_concept',\n        timestamp: new Date().toISOString(),\n        conceptId: nextConcept.id,\n        conceptTitle: nextConcept.title,\n        wasOverride: !orchestratorDecision.followingDefault // Track if this was an override\n      });\n    } else {\n      console.error(`Could not find concept with id ${nextId}`);\n      // Override to show completion if no valid concept found\n      orchestratorDecision.nextAction = 'concept_complete';\n    }\n  } else {\n    console.log('No remaining concepts - course should be complete');\n    // Override to show completion\n    orchestratorDecision.nextAction = 'concept_complete';\n  }\n}\n\n// PROMPT EXERCISE SAFETY CHECK - Now also checks if this was an override\nif (orchestratorDecision.nextAction === 'prompt_exercise') {\n  const shouldHavePromptTask = !!session.currentConcept?.shouldHavePromptTask;\n  \n  if (!shouldHavePromptTask) {\n    // Log that we're overriding an override\n    console.log(`Safety check: Overriding prompt_exercise decision - no shouldHavePromptTask defined for: ${session.currentConcept?.title}`);\n    \n    // Determine better fallback based on what tools have been used\n    if (!session.currentConceptTools.includes('assessment')) {\n      // Haven't done assessment yet - go there\n      orchestratorDecision.nextAction = 'assessment';\n      orchestratorDecision.reasoning = `Safety override: No prompt task defined. Proceeding to assessment.`;\n      orchestratorDecision.followingDefault = false;\n      orchestratorDecision.overrideReason = 'System safety check - no prompt task available';\n    } else if (session.lastAssessmentScore && session.lastAssessmentScore < 3) {\n      // Assessment done but score was low - consider remediation\n      orchestratorDecision.nextAction = 'insert_concept';\n      orchestratorDecision.reasoning = `Safety override: No prompt task defined. Low assessment score suggests remediation needed.`;\n      orchestratorDecision.followingDefault = false;\n      orchestratorDecision.overrideReason = 'System safety check - low score needs remediation';\n      orchestratorDecision.conceptNeeded = {\n        reason: \"Reinforce understanding based on low assessment score\",\n        focus: session.knowledgeGaps[0] || \"Core concept understanding\"\n      };\n    } else {\n      // Assessment done with decent score - safe to complete\n      orchestratorDecision.nextAction = 'concept_complete';\n      orchestratorDecision.reasoning = `Safety override: No prompt task defined. Assessment completed successfully.`;\n      orchestratorDecision.followingDefault = false;\n      orchestratorDecision.overrideReason = 'System safety check - ready to complete';\n    }\n  }\n}\n\n// HANDLE SKIP GRADING SIGNAL\nif (orchestratorDecision.skipGrading && session.pendingAssessment) {\n  // UPDATE STATE MACHINE - Track skipped assessment\n  session.stateMachine.previousState = session.stateMachine.currentState;\n  session.stateMachine.currentState = 'assessment_skipped';\n  session.stateMachine.stateHistory.push({\n    from: session.stateMachine.previousState,\n    to: 'assessment_skipped',\n    action: 'skip_assessment_grading',\n    timestamp: new Date().toISOString(),\n    skipReason: orchestratorDecision.skipReason || 'Based on learner note',\n    conceptId: session.currentConcept?.id,\n    wasOverride: !orchestratorDecision.followingDefault,\n    noteAnalysis: orchestratorDecision.noteAnalysis // Store note analysis for tracking\n  });\n  \n  // Track that assessment was skipped\n  if (!session.assessmentHistory) session.assessmentHistory = [];\n  session.assessmentHistory.push({\n    concept: session.currentConcept?.title,\n    conceptId: session.currentConcept?.id,\n    answer: session.pendingAssessment.answer,\n    note: session.pendingAssessment.note,\n    score: null,\n    skipped: true,\n    skipReason: orchestratorDecision.skipReason || 'Based on learner note',\n    timestamp: new Date().toISOString()\n  });\n  \n  // Clear pending assessment\n  session.pendingAssessment = null;\n}\n\n// HANDLE SKIP EVALUATION SIGNAL (for prompt exercises)\nif (orchestratorDecision.skipEvaluation && session.pendingPromptEvaluation) {\n  // UPDATE STATE MACHINE - Track skipped prompt evaluation\n  session.stateMachine.previousState = session.stateMachine.currentState;\n  session.stateMachine.currentState = 'prompt_evaluation_skipped';\n  session.stateMachine.stateHistory.push({\n    from: session.stateMachine.previousState,\n    to: 'prompt_evaluation_skipped',\n    action: 'skip_prompt_evaluation',\n    timestamp: new Date().toISOString(),\n    skipReason: orchestratorDecision.skipReason || 'Based on learner note',\n    conceptId: session.currentConcept?.id,\n    wasOverride: !orchestratorDecision.followingDefault,\n    noteAnalysis: orchestratorDecision.noteAnalysis\n  });\n  \n  // Clear pending evaluation state\n  if (!session.promptHistory) session.promptHistory = [];\n  session.promptHistory.push({\n    concept: session.currentConcept?.title,\n    conceptId: session.currentConcept?.id,\n    prompt: session.pendingPromptEvaluation.prompt,\n    note: session.pendingPromptEvaluation.note,\n    task: session.pendingPromptEvaluation.task,\n    score: null,\n    skipped: true,\n    skipReason: orchestratorDecision.skipReason || 'Based on learner note',\n    timestamp: new Date().toISOString()\n  });\n  \n  // Clear pending evaluation\n  session.pendingPromptEvaluation = null;\n  \n  // Also clear the current prompt exercise since we're skipping\n  session.currentPromptExercise = null;\n}\n\n// HANDLE MARK AS COMPLETE SIGNAL (for skipping concepts)\nif (orchestratorDecision.markAsComplete && orchestratorDecision.completionType === 'skipped') {\n  // UPDATE STATE MACHINE - Track concept skip\n  session.stateMachine.previousState = session.stateMachine.currentState;\n  session.stateMachine.currentState = 'concept_skipped';\n  session.stateMachine.stateHistory.push({\n    from: session.stateMachine.previousState,\n    to: 'concept_skipped',\n    action: 'skip_concept',\n    timestamp: new Date().toISOString(),\n    skipReason: orchestratorDecision.skipReason || 'Learner requested skip',\n    conceptId: session.currentConcept?.id,\n    conceptTitle: session.currentConcept?.title,\n    toolsCompleted: session.currentConceptTools,\n    wasOverride: true, // Skipping is always an override\n    noteAnalysis: orchestratorDecision.noteAnalysis\n  });\n  \n  // Track as skipped concept - Only if we have a current concept\n  if (session.currentConcept) {\n    session.skippedConcepts.push({\n      conceptId: session.currentConcept.id,\n      conceptTitle: session.currentConcept.title,\n      reason: orchestratorDecision.skipReason || 'Learner requested skip',\n      toolsCompleted: session.currentConceptTools,\n      hadPendingAssessment: !!session.pendingAssessment,\n      hadPendingPromptEvaluation: !!session.pendingPromptEvaluation,\n      timestamp: new Date().toISOString(),\n      noteAnalysis: orchestratorDecision.noteAnalysis // Store for analysis\n    });\n  }\n  \n  // Clear any pending assessment/evaluation data\n  session.pendingAssessment = null;\n  session.pendingPromptEvaluation = null;\n  session.lastAssessmentScore = null;\n  \n  // Override action to concept_complete to move forward\n  orchestratorDecision.nextAction = 'concept_complete';\n}\n\n// EXISTING GAP ATTEMPT LOGIC\n// Check if we're trying to insert a concept for a gap we've already attempted multiple times\nif (orchestratorDecision.nextAction === 'insert_concept' && session.knowledgeGaps.length > 0) {\n  const targetGap = session.knowledgeGaps[0];\n  const attempts = session.gapAttempts[targetGap] || 0;\n  \n  if (attempts >= 2) {\n    // Override the orchestrator's decision\n    orchestratorDecision.nextAction = 'concept_complete';\n    orchestratorDecision.reasoning = `Gap \"${targetGap}\" has been attempted ${attempts} times. Moving forward with core curriculum.`;\n    orchestratorDecision.followingDefault = false;\n    orchestratorDecision.overrideReason = 'Maximum gap attempts reached';\n    \n    // Move gap to deferred list\n    session.knowledgeGaps = session.knowledgeGaps.filter(gap => gap !== targetGap);\n    session.deferredGaps.push({\n      gap: targetGap,\n      attempts: attempts,\n      deferredAt: new Date().toISOString()\n    });\n  }\n}\n\n// Store orchestrator decision for reference - Enhanced with new fields\nsession.lastOrchestratorDecision = {\n  decision: orchestratorDecision,\n  timestamp: new Date().toISOString(),\n  followedDefault: orchestratorDecision.followingDefault,\n  defaultWas: originalData.defaultNextAction?.action,\n  noteAnalysis: orchestratorDecision.noteAnalysis\n};\n\n// Store exercise focus if provided\nif (orchestratorDecision.exerciseFocus) {\n  session.currentExerciseFocus = orchestratorDecision.exerciseFocus;\n}\n\n// LEARNER NOTE TRACKING - New addition to track all notes\nif (orchestratorDecision.noteAnalysis && originalData.learnerInput?.note) {\n  if (!session.learnerNoteHistory) session.learnerNoteHistory = [];\n  session.learnerNoteHistory.push({\n    timestamp: new Date().toISOString(),\n    conceptId: session.currentConcept?.id,\n    conceptTitle: session.currentConcept?.title,\n    note: originalData.learnerInput.note,\n    analysis: orchestratorDecision.noteAnalysis,\n    actionTaken: orchestratorDecision.nextAction,\n    wasOverride: !orchestratorDecision.followingDefault\n  });\n}\n\n// Save updated state back to global\n$getWorkflowStaticData('global').sessions[sessionId] = session;\n\n// Pass forward with the orchestrator decision AND current concept\nreturn {\n  ...originalData,\n  orchestratorDecision,\n  sessionState: session,\n  nextAction: orchestratorDecision.nextAction,\n  currentConcept: session.currentConcept, // IMPORTANT: Pass the current concept\n  // Add tracking info for debugging\n  decisionTracking: {\n    followedDefault: orchestratorDecision.followingDefault,\n    defaultAction: originalData.defaultNextAction?.action,\n    chosenAction: orchestratorDecision.nextAction,\n    overrideReason: orchestratorDecision.overrideReason\n  }\n};"
      },
      "id": "2420d12f-4baf-487b-946f-1ee34c25f512",
      "name": "Process Adaptive Orchestrator Decision",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -2640,
        875
      ]
    },
    {
      "parameters": {
        "jsCode": "// Smart Reply Generator for 6 Input Handlers\nconst toolType = $json.responseData?.toolType;\nconst toolData = $json.responseData?.toolData;\nconst sessionId = $json.sessionId;\n\n// Get session for context\nconst session = $getWorkflowStaticData('global').sessions[sessionId];\n\n// Determine which handler sent this based on context\nlet inputSource = '';\nif ($json.needsGrading && toolType === 'assessment') {\n  inputSource = 'assessment_handler';\n} else if ($json.gradingResult && toolType === 'assessment') {\n  inputSource = 'process_grading';\n} else if ($json.evaluationResult && toolType === 'prompt_exercise') {\n  inputSource = 'process_prompt_evaluation';\n} else if ($json.enhancedPromptTask && toolType === 'prompt_exercise') {\n  inputSource = 'process_generated_prompt';\n} else if (toolType === 'concept_card') {\n  inputSource = 'concept_card_handler';\n} else if (toolType === 'transition') {\n  inputSource = 'complete_concept_handler';\n}\n\n// Build context for smart reply generation\nlet contextPrompt = '';\n\nswitch(inputSource) {\n  case 'concept_card_handler':\n    // Input 1: Concept Card Handler - showing concept for first time\n    contextPrompt = `Tool: Concept Card (Initial Display)\nCurrent Concept: ${toolData.title}\nSummary: ${toolData.summary}\nLearner Role: ${$json.learnerProfile?.role || 'Product Manager'}\nStatus: Learner is reading this concept and can add notes\n\nGenerate 5 smart reply options for notes they might want to add:\n- Question about applying this to their role\n- Request for concrete examples\n- Express confusion about specific aspect\n- Indicate they already know this\n- Ask how this relates to previous concepts`;\n    break;\n  case 'assessment_handler':\n    // Input 2: Assessment Handler - just submitted answer, waiting for grading\n    contextPrompt = `Tool: Assessment (Answer Submitted, Pre-Grading)\nQuestion: ${toolData.question}\nConcept: ${toolData.conceptTitle}\nLearner Role: ${$json.learnerProfile?.role || 'Product Manager'}\nStatus: Answer submitted, can add a note before grading\n\nGenerate 5 smart reply options for notes about their answer:\n- Admit uncertainty or guessing\n- Challenge the question wording\n- Explain their reasoning\n- Point out ambiguity in options\n- Request hint or clarification`;\n    break;\n    \n  case 'process_grading':\n    // Input 3: Process Grading - seeing their score and feedback\n    const score = toolData.gradingResult?.score || 0;\n    contextPrompt = `Tool: Assessment Results (Post-Grading)\nQuestion: ${toolData.question}\nScore: ${score}/5\nFeedback: ${toolData.gradingResult?.feedback}\nLearner Role: ${$json.learnerProfile?.role || 'Product Manager'}\nStatus: Viewing grading results\n\nGenerate 5 smart reply options based on score ${score}/5:\n${score >= 4 ? \n'- Express satisfaction\\n- Ask for advanced application\\n- Ready for harder challenges\\n- Connect to their work context\\n- Move to next concept' : \nscore >= 2 ? \n'- Ask for clarification\\n- Request another example\\n- Partial understanding acknowledgment\\n- Disagree with grading\\n- Need more practice' : \n'- Express frustration\\n- Request detailed explanation\\n- Ask for simpler version\\n- Need to review concept\\n- Want personal help'}`;\n    break;\n    \n  case 'process_prompt_evaluation':\n    // Input 4: Process Prompt Evaluation - seeing evaluation results\n    const promptScore = toolData.evaluationResult?.score || 0;\n    contextPrompt = `Tool: Prompt Exercise Results (Post-Evaluation)\nTask: ${toolData.task}\nScore: ${promptScore}/5\nFeedback: ${toolData.evaluationResult?.feedback}\nAI Response: ${toolData.evaluationResult?.simulatedAIResponse ? 'Shown' : 'Not shown'}\nLearner Role: ${$json.learnerProfile?.role || 'Product Manager'}\nStatus: Viewing prompt evaluation\n\nGenerate 5 smart reply options for score ${promptScore}/5:\n- ${promptScore >= 4 ? 'Want more advanced prompting' : 'Need better examples'}\n- ${promptScore >= 4 ? 'Try industry-specific prompt' : 'Request prompt templates'}\n- ${promptScore >= 3 ? 'Understand the feedback' : 'Confused by evaluation'}\n- Ask about best practices\n- ${promptScore < 3 ? 'Want to retry' : 'Ready to continue'}`;\n    break;\n    \n  case 'process_generated_prompt':\n    // Input 5: Process Generated Prompt Exercise - seeing the enhanced exercise\n    const difficulty = toolData.difficulty || 'unknown';\n    contextPrompt = `Tool: Prompt Exercise (Enhanced Task Display)\nTask: ${toolData.task}\nContext: ${toolData.context || 'None'}\nHints Available: ${toolData.hints?.length || 0}\nDifficulty: ${difficulty}\nLearner Role: ${$json.learnerProfile?.role || 'Product Manager'}\nStatus: Viewing prompt exercise task\n\nGenerate 5 smart reply options for task difficulty \"${difficulty}\":\n- ${difficulty === 'advanced' ? 'This looks challenging' : 'I can handle this'}\n- ${toolData.hints?.length ? 'Show me a hint' : 'Need more context'}\n- Ask about evaluation criteria\n- ${difficulty === 'beginner' ? 'Too easy for me' : 'Request simpler version'}\n- Connect to their ${$json.learnerProfile?.role} role`;\n    break;\n    \n  case 'complete_concept_handler':\n    // Input 6: Complete Concept - transitioning between concepts\n    const completedTitle = toolData.completedConcept || session.currentConcept?.title;\n    const wasSkipped = session.skippedConcepts?.some(\n      skip => skip.conceptTitle === completedTitle\n    );\n    const lastScore = session.lastAssessmentScore;\n    \n    contextPrompt = `Tool: Concept Transition\nJust Completed: ${completedTitle}\nCompletion Type: ${wasSkipped ? 'Skipped' : lastScore >= 4 ? 'Mastered' : lastScore >= 3 ? 'Adequate' : 'Struggled'}\nAssessment Score: ${lastScore || 'N/A'}/5\nProgress: ${session.completedConcepts?.length || 0} concepts done\nStatus: Moving to next concept\n\nGenerate 5 smart reply options for this transition:\n${wasSkipped ? \n'- Why I skipped this\\n- Actually, let me try it\\n- I already know this well\\n- Move to next topic\\n- Will this hurt my progress?' :\nlastScore < 3 ? \n'- Wait, I need review\\n- Still confused about X\\n- Can we go slower?\\n- Show me similar concept\\n- I need a break' :\n'- Great, what\\'s next?\\n- How does this connect?\\n- That was helpful\\n- Ready for harder stuff\\n- Can I reference this later?'}`;\n    break;\n    \n  default:\n    // Fallback - should not happen with proper routing\n    contextPrompt = `Tool: Unknown Input Source\nCurrent State: ${session.stateMachine?.currentState}\nTool Type: ${toolType}\nLearner Role: ${$json.learnerProfile?.role || 'Product Manager'}\n\nGenerate 5 general smart reply options for learning.`;\n}\n\n// Add session context to all prompts\nconst additionalContext = `\n\nAdditional Context:\n- Knowledge Gaps: ${session.knowledgeGaps?.join(', ') || 'None identified'}\n- Knowledge Strengths: ${session.knowledgeStrengths?.join(', ') || 'None identified'}\n- Recent Questions: ${session.recentQuestions?.slice(-2).join('; ') || 'None'}\n- Learning Progress: ${session.completedConcepts?.length || 0} concepts completed\n- Current State: ${session.stateMachine?.currentState}\n- Last Tool Used: ${session.lastToolUsed}`;\n\nconst messages = [\n  {\n    role: \"system\",\n    content: \"You are an adaptive learning assistant generating smart reply options for learners. Create short, natural responses that a learner might click instead of typing. Each reply should be under 10 words and feel conversational. Make them contextually relevant and emotionally appropriate to the learner's current situation.\"\n  },\n  {\n    role: \"user\",\n    content: `${contextPrompt}${additionalContext}\n\nReturn a JSON object with exactly this structure:\n{\n  \"replies\": [\"Reply 1\", \"Reply 2\", \"Reply 3\", \"Reply 4\", \"Reply 5\"]\n}\n\nMake replies:\n1. Contextually relevant to the specific handler and state\n2. Natural and conversational (how real learners talk)\n3. Actionable and specific\n4. Varied in intent (questions, confirmations, concerns, requests)\n5. Emotionally appropriate (encouraging for struggles, challenging for high performers)\n6. Under 10 words each`\n  }\n];\n\nreturn {\n  messages,\n  model: \"gpt-4o\",\n  temperature: 0.7,\n  max_tokens: 300,\n  response_format: { type: \"json_object\" },\n  // Pass through ALL the original data\n  originalData: $json\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -440,
        996
      ],
      "id": "37d29304-8841-424a-ac9c-9e55c72d0f56",
      "name": "Smart Reply Generator Prompt"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://api.openai.com/v1/chat/completions",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "openAiApi",
        "sendBody": true,
        "bodyParameters": {
          "parameters": [
            {
              "name": "model",
              "value": "={{ $json.model }}"
            },
            {
              "name": "messages",
              "value": "={{ $json.messages }}"
            },
            {
              "name": "temperature",
              "value": "={{ $json.temperature }}"
            },
            {
              "name": "max_tokens",
              "value": "={{ $json.max_tokens }}"
            },
            {
              "name": "response_format",
              "value": "={{ $json.response_format }}"
            }
          ]
        },
        "options": {}
      },
      "id": "b3949255-4c59-417e-985e-a158b6d70b53",
      "name": "Smart Reply Generator AI Call",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -220,
        996
      ],
      "credentials": {
        "openAiApi": {
          "id": "UFaW72U0IV5U0Ec5",
          "name": "OpenAi account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Process Smart Replies - Add generated replies to response\nconst smartReplies = JSON.parse($json.choices[0].message.content);\n\n// Get data from the pipeline (from Smart Reply Generator AI Call)\nconst originalData = $('Smart Reply Generator Prompt').first().json.originalData;\n\n// Add smart replies to the response\nconst enhancedResponse = {\n  ...originalData,\n  responseData: {\n    ...originalData.responseData,\n    toolData: {\n      ...originalData.responseData.toolData,\n      smartReplies: Array.isArray(smartReplies) ? smartReplies : Object.values(smartReplies)\n    }\n  }\n};\n\nreturn enhancedResponse;"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        0,
        996
      ],
      "id": "74959534-a145-472e-99b2-51199699ffe2",
      "name": "Process Smart Replies"
    },
    {
      "parameters": {
        "jsCode": "// Generate Prompt Exercise - Creates targeted prompt exercises\nconst sessionId = $json.sessionId;\nconst session = $getWorkflowStaticData('global').sessions[sessionId];\n\nif (!session) {\n  throw new Error(`Session ${sessionId} not found in global state`);\n}\n\nconst messages = [\n  {\n    role: \"system\",\n    content: \"You are an expert instructional designer creating prompt engineering exercises for product managers. Create exercises that test practical application of AI concepts in product management contexts.\"\n  },\n  {\n    role: \"user\", \n    content: `Context:\n- Course Topic: ${$json.courseTopic}\n- Current Concept: ${session.currentConcept?.title || 'Unknown'}\n- Concept Summary: ${session.currentConcept?.summary || 'N/A'}\n- Learner Profile: ${$json.learnerProfile.role} at ${$json.learnerProfile.company}\n- Learner Skills: ${$json.learnerProfile.skills.join(', ')}\n\nKnowledge State:\n- Strengths: ${session.knowledgeStrengths?.join(', ') || 'None tracked yet'}\n- Gaps: ${session.knowledgeGaps?.join(', ') || 'None tracked yet'}\n- Recent Assessment Score: ${session.lastAssessmentScore || 'N/A'}/5\n\nPrevious Interactions:\n- Tools Used This Concept: ${session.currentConceptTools.join(', ')}\n- Recent Questions: ${session.recentQuestions?.slice(-2).join('; ') || 'None'}\n\n${session.orchestratorDecision?.exerciseFocus ? \n  `Special Focus: Create an exercise that specifically addresses: \"${session.orchestratorDecision.exerciseFocus}\"` : \n  'Create a prompt exercise that reinforces the current concept.'}\n\nGenerate a prompt exercise that:\n1. Is directly relevant to \"${session.currentConcept?.title}\"\n2. Tests practical application in their role as ${$json.learnerProfile.role}\n3. Addresses any identified knowledge gaps\n4. Builds on their existing strengths\n5. Is appropriately challenging based on their assessment score\n\nReturn JSON:\n{\n  \"task\": \"Clear, specific task description\",\n  \"context\": \"Brief scenario or context for the task\",\n  \"expectedOutcomes\": [\"What a good prompt should achieve\"],\n  \"hints\": [\"2-3 helpful hints without giving away the answer\"],\n  \"evaluationCriteria\": {\n    \"must_include\": [\"Key elements that must be in the prompt\"],\n    \"should_consider\": [\"Important considerations\"],\n    \"avoid\": [\"Common mistakes to avoid\"]\n  },\n  \"difficulty\": \"beginner|intermediate|advanced\",\n  \"targetedSkills\": [\"specific skills being tested\"]\n}`\n  }\n];\n\nreturn {\n  messages,\n  model: \"gpt-4o\",\n  temperature: 0.7,\n  max_tokens: 800,\n  response_format: { type: \"json_object\" },\n  originalData: $json\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1100,
        1475
      ],
      "id": "595ebb3c-f347-46f2-8d5d-25dfeee6526b",
      "name": "Generate Prompt Exercise Prompt"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://api.openai.com/v1/chat/completions",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "openAiApi",
        "sendBody": true,
        "bodyParameters": {
          "parameters": [
            {
              "name": "model",
              "value": "={{ $json.model }}"
            },
            {
              "name": "messages",
              "value": "={{ $json.messages }}"
            },
            {
              "name": "temperature",
              "value": "={{ $json.temperature }}"
            },
            {
              "name": "max_tokens",
              "value": "={{ $json.max_tokens }}"
            },
            {
              "name": "response_format",
              "value": "={{ $json.response_format }}"
            }
          ]
        },
        "options": {}
      },
      "id": "3575f197-7a1e-4410-b8f1-c2ed369c2c9f",
      "name": "Generate Prompt Exercise Evaluation AI Call",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -1980,
        650
      ],
      "credentials": {
        "openAiApi": {
          "id": "UFaW72U0IV5U0Ec5",
          "name": "OpenAi account"
        }
      }
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://api.openai.com/v1/chat/completions",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "openAiApi",
        "sendBody": true,
        "bodyParameters": {
          "parameters": [
            {
              "name": "model",
              "value": "={{ $json.model }}"
            },
            {
              "name": "messages",
              "value": "={{ $json.messages }}"
            },
            {
              "name": "temperature",
              "value": "={{ $json.temperature }}"
            },
            {
              "name": "max_tokens",
              "value": "={{ $json.max_tokens }}"
            },
            {
              "name": "response_format",
              "value": "={{ $json.response_format }}"
            }
          ]
        },
        "options": {}
      },
      "id": "b12839bf-30c0-480e-89bf-fd421dcd9e51",
      "name": "Generate Prompt Exercise Generate AI Call",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -880,
        1475
      ],
      "credentials": {
        "openAiApi": {
          "id": "UFaW72U0IV5U0Ec5",
          "name": "OpenAi account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// This node processes the AI's evaluation of the user's prompt\n\nconst evaluationResult = JSON.parse($json.choices[0].message.content);\n\n// Get data from the pipeline (from Generate Prompt Exercise Evaluation AI Call)\nconst originalData = $('Generate Evaluate Prompt Excercise Prompt').first().json.originalData;\nconst sessionId = originalData.sessionId;\nconst responseData = originalData.responseData;\n\n// Get session from global\nconst session = $getWorkflowStaticData('global').sessions[sessionId];\n\n// UPDATE STATE MACHINE\nsession.stateMachine.previousState = session.stateMachine.currentState;\nsession.stateMachine.currentState = 'prompt_evaluated';\nsession.stateMachine.stateHistory.push({\n  from: session.stateMachine.previousState,\n  to: 'prompt_evaluated',\n  action: 'evaluation_complete',\n  timestamp: new Date().toISOString(),\n  score: evaluationResult.score,\n  conceptId: session.currentConcept?.id,\n  conceptTitle: session.currentConcept?.title\n});\n\n// Update knowledge state based on evaluation\nif (evaluationResult.knowledgeUpdate) {\n  // Add mastered concepts to strengths\n  evaluationResult.knowledgeUpdate.masteredConcepts.forEach(concept => {\n    if (!session.knowledgeStrengths.includes(concept)) {\n      session.knowledgeStrengths.push(concept);\n    }\n  });\n  \n  // Update gaps - remove mastered ones, add new ones\n  session.knowledgeGaps = session.knowledgeGaps.filter(\n    gap => !evaluationResult.knowledgeUpdate.masteredConcepts.includes(gap)\n  );\n  \n  evaluationResult.knowledgeUpdate.identifiedGaps.forEach(gap => {\n    if (!session.knowledgeGaps.includes(gap)) {\n      session.knowledgeGaps.push(gap);\n    }\n  });\n  \n  // Track in knowledge evolution\n  if (!session.knowledgeEvolution) {\n    session.knowledgeEvolution = [];\n  }\n  \n  session.knowledgeEvolution.push({\n    timestamp: new Date().toISOString(),\n    tool: 'prompt_exercise',\n    concept: session.currentConcept.title,\n    conceptId: session.currentConcept.id,\n    score: evaluationResult.score,\n    mastered: evaluationResult.knowledgeUpdate.masteredConcepts,\n    gaps: evaluationResult.knowledgeUpdate.identifiedGaps,\n    reasoning: evaluationResult.knowledgeUpdate.reasoning\n  });\n}\n\n// Clear pending evaluation\nsession.pendingPromptEvaluation = null;\n\n// Save updated state\n$getWorkflowStaticData('global').sessions[sessionId] = session;\n\n// Create updated response data with evaluation results\nconst updatedResponseData = {\n  ...responseData,\n  toolData: {\n    ...responseData.toolData,\n    evaluationResult: evaluationResult\n  },\n  waitingForInput: false,\n  nextAction: 'Click Next to continue to the next concept.'\n};\n\n// Pass all necessary data forward in the pipeline\nreturn {\n  ...originalData,\n  evaluationResult,\n  responseData: updatedResponseData,\n  sessionId,\n  learnerProfile: originalData.learnerProfile\n};"
      },
      "id": "26b5b049-d975-45a7-b455-4305170199de",
      "name": "Process Prompt Evaluation",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1760,
        650
      ]
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// Generate Assessment Grading Prompt - FIXED to properly get learner answer\nconst sessionId = $json.sessionId;\nconst session = $getWorkflowStaticData('global').sessions[sessionId];\n\nif (!session) {\n  throw new Error(`Session ${sessionId} not found in global state`);\n}\n\n// Get the learner's answer from the input\nconst learnerAnswer = $json.learnerInput?.answer;\n\nif (!learnerAnswer) {\n  throw new Error('No learner answer found in the input');\n}\n\nconst messages = [\n  {\n    role: \"system\",\n    content: \"You are an expert instructional coach who evaluates learner understanding AND tracks their evolving knowledge state. Analyze both the current answer and overall knowledge progression.\"\n  },\n  {\n    role: \"user\", \n    content: `Context:\n- Course Topic: ${$json.courseTopic}\n- Current Concept: ${session.currentConcept.title}\n- Question: ${session.currentConcept.assessmentQuestion}\n- Correct Answer: ${session.currentConcept.correctAnswer}\n- Learner's Answer: ${learnerAnswer}\n- Learner Profile: ${$json.learnerProfile.role} at ${$json.learnerProfile.company}\n\nCurrent Knowledge State:\n- Strengths: ${session.knowledgeStrengths?.join(', ') || 'None tracked yet'}\n- Gaps: ${session.knowledgeGaps?.join(', ') || 'None tracked yet'}\n\nAssessment Context:\n- Is this a dynamic concept?: ${session.currentConcept.isDynamic || false}\n- Targeted gaps (if dynamic): ${session.currentConcept.targetedGaps?.join(', ') || 'N/A'}\n- Previous score: ${session.lastAssessmentScore || 'N/A'}\n\nEvaluate the answer AND update their knowledge state. Return JSON:\n{\n  \"score\": (0-5 number),\n  \"feedback\": \"Brief, encouraging feedback\",\n  \"understood\": (true or false),\n  \"knowledgeUpdate\": {\n    \"updatedStrengths\": [\"Complete list of what learner knows well\"],\n    \"updatedGaps\": [\"Complete list of significant gaps needing attention\"],\n    \"reasoning\": \"Brief explanation of knowledge state changes\"\n  }\n}\n\nGrading Rules:\n- 5: Perfect understanding\n- 4: Good understanding with minor gaps\n- 3: Adequate understanding for progression\n- 2: Significant gaps but some understanding\n- 0-1: Major misunderstanding\n\nKnowledge Rules:\n- Add strengths for demonstrated understanding (scores 3+)\n- Remove gaps that were successfully addressed\n- Only list actionable, specific gaps\n- For dynamic concepts addressing gaps, be generous if progress is shown\n- Empty gaps array means no significant issues`\n  }\n];\n\nreturn {\n  messages,\n  model: \"gpt-4o\",\n  temperature: 0.3,\n  max_tokens: 400,\n  response_format: { type: \"json_object\" },\n  // Pass through all necessary data for processing\n  originalData: {\n    sessionId: $json.sessionId,\n    courseTopic: $json.courseTopic,\n    learnerAnswer: learnerAnswer,\n    learnerProfile: $json.learnerProfile,\n    learnerInput: $json.learnerInput\n  }\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -2200,
        450
      ],
      "id": "54560bf3-5b60-4b13-bc9a-7a791d4c925e",
      "name": "Generate Assessment Grading Prompt"
    },
    {
      "parameters": {
        "jsCode": "// Process Generated Prompt Exercise - FIXED\nconst exerciseData = JSON.parse($json.choices[0].message.content);\n\n// Get data from the pipeline\nconst sessionId = $('Generate Prompt Exercise Prompt').first().json.originalData.sessionId;\nconst originalData = $('Generate Prompt Exercise Prompt').first().json.originalData;\n\n// Get session from global\nconst session = $getWorkflowStaticData('global').sessions[sessionId];\n\n// Store the enhanced task in session\nsession.currentPromptExercise = exerciseData;\n\n// Save updated state\n$getWorkflowStaticData('global').sessions[sessionId] = session;\n\n// HERE'S THE KEY: Build the response with the ACTUAL enhanced task data\nconst responseData = {\n  sessionId,\n  toolType: 'prompt_exercise',\n  conceptProgress: {\n    current: session.completedConcepts.length + 1,\n    total: session.remainingCoreConcepts.length + \n           session.completedConcepts.length + \n           session.insertedConcepts.length\n  },\n  toolData: {\n    task: exerciseData.task,  // Use the actual generated task\n    context: exerciseData.context,\n    hints: exerciseData.hints,\n    conceptTitle: session.currentConcept?.title,\n    difficulty: exerciseData.difficulty\n  },\n  waitingForInput: true,\n  inputType: 'prompt',\n  message: 'Practice your prompt engineering skills with this task.'\n};\n\n// Pass the enhanced response forward\nreturn {\n  ...originalData,\n  responseData,  // This contains the enhanced task\n  sessionId,\n  learnerProfile: originalData.learnerProfile\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -660,
        1475
      ],
      "id": "3c50e1c8-db67-4701-a15a-0442e5ccfe22",
      "name": "Process Generated Prompt Exercise"
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// Simplified Generate Adaptive Orchestrator Router Prompt\n// This focuses on learner notes and pedagogical overrides\n\nconst messages = [\n  {\n    role: \"system\",\n    content: `You are an adaptive learning orchestrator that adds INTELLIGENCE to the learning flow. The Core Orchestrator has already determined the DEFAULT next action based on standard progression rules. Your job is to:\n\n1. PRIORITIZE learner notes and questions - this is where you add the most value\n2. Override the default ONLY when there's a strong pedagogical reason\n3. Insert remedial concepts when knowledge gaps are detected\n4. Skip content when learners demonstrate mastery or explicitly request it\n\nYou are the \"human touch\" that makes the system adaptive and responsive to individual needs.`\n  },\n  {\n    role: \"user\", \n    content: `📋 DEFAULT NEXT ACTION (from Core Orchestrator):\n━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\nAction: \"${$json.defaultNextAction?.action}\"\nReason: \"${$json.defaultNextAction?.reason}\"\n${$json.defaultNextAction?.isRequired ? '⚠️ This is a REQUIRED step in the flow' : ''}\n${$json.defaultNextAction?.isOptional ? 'ℹ️ This is optional and can be skipped' : ''}\n${$json.defaultNextAction?.suggestRemediation ? '💡 Low score - consider remediation' : ''}\n\n📊 CURRENT CONTEXT:\n━━━━━━━━━━━━━━━\n- Current Concept: ${session.currentConcept?.title || 'None'}\n- Tools Completed: [${$json.orchestratorContext.currentProgress.toolsCompleted.join(', ')}]\n- Assessment Score: ${$json.orchestratorContext.currentProgress.assessmentScore || 'Not assessed yet'}\n- Knowledge Gaps: ${$json.orchestratorContext.learnerContext.knowledgeGaps?.join(', ') || 'None identified'}\n- Knowledge Strengths: ${$json.orchestratorContext.learnerContext.knowledgeStrengths?.join(', ') || 'None identified'}\n\n${$json.orchestratorContext.learnerContext.hasNote ? `\n🎯 LEARNER NOTE (HIGHEST PRIORITY):\n━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\"${$json.orchestratorContext.learnerContext.noteContent}\"\n\nANALYZE THIS NOTE FOR:\n1. 🤔 Confusion/Questions → Consider insert_concept to clarify\n2. 🎓 Mastery signals (\"I know this\", \"too easy\") → Consider skipping\n3. 🔄 Requests (\"show example\", \"more practice\") → Address directly\n4. 😕 Frustration → Slow down, provide support\n5. 💡 Connections to their role → Enhance with examples\n6. ⏭️ Skip requests → Honor them (set markAsComplete: true)\n\nRecent questions from learner: ${$json.orchestratorContext.learnerContext.recentQuestions?.join('; ') || 'None'}\n` : ''}\n\n🤖 YOUR DECISION FRAMEWORK:\n━━━━━━━━━━━━━━━━━━━━━━━\n\nWHEN TO OVERRIDE THE DEFAULT:\n1. ✅ Learner note indicates confusion → insert_concept\n2. ✅ Learner demonstrates mastery → skip to concept_complete  \n3. ✅ Knowledge gaps + low score → insert_concept for remediation\n4. ✅ Explicit skip request → concept_complete with skip flags\n5. ✅ Request for examples/practice → insert_concept with specific focus\n\nWHEN TO KEEP THE DEFAULT:\n1. ✅ No learner note AND standard progression makes sense\n2. ✅ Default is a required step (like assessment after concept_card)\n3. ✅ Learner is progressing normally without issues\n\n${session.pendingAssessment ? `\n📝 PENDING ASSESSMENT DECISION:\n- Answer: \"${session.pendingAssessment.answer}\"\n- Note: \"${session.pendingAssessment.note}\"\n- Default would be: grade_assessment\n\nShould we grade this or skip based on the note?\n` : ''}\n\n${session.pendingPromptEvaluation ? `\n💡 PENDING PROMPT EVALUATION:\n- Prompt: \"${session.pendingPromptEvaluation.prompt}\"\n- Note: \"${session.pendingPromptEvaluation.note || 'None'}\"\n- Default would be: evaluate_prompt\n\nShould we evaluate this or skip based on the note?\n` : ''}\n\nREMEMBER: You add value by being responsive to the learner's individual needs. The default action is just a suggestion - override it when the learner would benefit from a different path.\n\nReturn JSON with EXACTLY this format:\n{\n  \"nextAction\": \"grade_assessment|evaluate_prompt|concept_card|assessment|prompt_exercise|concept_complete|insert_concept\",\n  \"reasoning\": \"Brief explanation of decision (mention if following default or overriding)\",\n  \"followingDefault\": true|false,\n  \"overrideReason\": \"Only if followingDefault is false, explain the pedagogical reason\",\n  \n  // ONLY include these if applicable:\n  \"skipGrading\": true|false, // Only if assessment is pending and should be skipped\n  \"skipEvaluation\": true|false, // Only if prompt evaluation is pending and should be skipped\n  \"markAsComplete\": true|false, // Only if learner wants to skip the concept\n  \"completionType\": \"normal|skipped\", // Only if markAsComplete is true\n  \"skipReason\": \"reason for skipping\", // Only if skipping something\n  \n  // Only if nextAction is \"prompt_exercise\":\n  \"exerciseFocus\": \"specific focus for the prompt exercise\",\n  \n  // Only if nextAction is \"insert_concept\":\n  \"conceptNeeded\": {\n    \"reason\": \"specific gap or confusion to address\",\n    \"focus\": \"topic area for the new concept\"\n  },\n  \n  // Always include note analysis if there was a learner note:\n  \"noteAnalysis\": {\n    \"understanding\": \"low|medium|high\",\n    \"needsClarification\": true|false,\n    \"wantsToSkip\": true|false,\n    \"specificRequest\": \"what they're asking for if clear\",\n    \"sentiment\": \"confused|curious|confident|frustrated|dismissive\"\n  }\n}\n\nEXAMPLES:\n\n1. Following default (no issues):\n{\n  \"nextAction\": \"assessment\",\n  \"reasoning\": \"Following default progression - assessment comes after concept card\",\n  \"followingDefault\": true\n}\n\n2. Overriding due to confusion:\n{\n  \"nextAction\": \"insert_concept\",\n  \"reasoning\": \"Overriding default (assessment) because learner expressed confusion about AI tool categories\",\n  \"followingDefault\": false,\n  \"overrideReason\": \"Learner needs clarification before assessment would be meaningful\",\n  \"conceptNeeded\": {\n    \"reason\": \"Learner confused about difference between chat-based vs integrated AI tools\",\n    \"focus\": \"AI tool categories and use cases\"\n  },\n  \"noteAnalysis\": {\n    \"understanding\": \"low\",\n    \"needsClarification\": true,\n    \"wantsToSkip\": false,\n    \"specificRequest\": \"wants examples of different AI tool types\",\n    \"sentiment\": \"confused\"\n  }\n}\n\n3. Honoring skip request:\n{\n  \"nextAction\": \"concept_complete\",\n  \"reasoning\": \"Learner indicates they already know this material well\",\n  \"followingDefault\": false,\n  \"overrideReason\": \"Learner demonstrates existing mastery\",\n  \"markAsComplete\": true,\n  \"completionType\": \"skipped\",\n  \"skipReason\": \"Learner already familiar with concept\",\n  \"noteAnalysis\": {\n    \"understanding\": \"high\",\n    \"needsClarification\": false,\n    \"wantsToSkip\": true,\n    \"specificRequest\": \"skip to next topic\",\n    \"sentiment\": \"confident\"\n  }\n}`\n  }\n];\n\nreturn {\n  messages,\n  model: \"gpt-4o\",\n  temperature: 0.3,\n  max_tokens: 500,\n  response_format: { type: \"json_object\" },\n  // Pass through original data\n  originalData: {\n    sessionId: $json.sessionId,\n    action: $json.action,\n    learnerInput: $json.learnerInput,\n    courseTopic: $json.courseTopic,\n    learnerProfile: $json.learnerProfile,\n    coreConcepts: $json.coreConcepts,\n    userName: $json.userName,\n    currentConcept: session.currentConcept,\n    defaultNextAction: $json.defaultNextAction,\n    orchestratorContext: $json.orchestratorContext,\n    stateMachine: {\n      currentState: session.stateMachine.currentState\n    }\n  }\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -3080,
        875
      ],
      "id": "09b3fb2e-a46c-4a40-aab2-af9903280fe0",
      "name": "Generate Adaptive Orchestrator Router Prompt"
    },
    {
      "parameters": {
        "jsCode": "// This node prepares the prompt for evaluating user's prompt exercise submission\n\n// Prepare Prompt Evaluation Request\nconst sessionId = $json.sessionId;\nconst session = $getWorkflowStaticData('global').sessions[sessionId];\n\nif (!session || !session.pendingPromptEvaluation) {\n  throw new Error('No pending prompt evaluation found');\n}\n\nconst messages = [\n  {\n    role: \"system\",\n    content: \"You are an expert at evaluating AI prompts for product management tasks AND tracking knowledge mastery. Analyze both the prompt quality and what it reveals about the learner's understanding.\"\n  },\n  {\n    role: \"user\",\n    content: `Task: ${session.pendingPromptEvaluation.task}\nLearner's Prompt: ${session.pendingPromptEvaluation.prompt}\nLearner Background: ${$json.learnerProfile.role} with skills in ${$json.learnerProfile.skills.join(', ')}\n\nEvaluation Criteria:\n${JSON.stringify(session.pendingPromptEvaluation.evaluationCriteria || {})}\n\nCurrent Knowledge State:\n- Strengths: ${session.knowledgeStrengths?.join(', ') || 'None'}\n- Gaps: ${session.knowledgeGaps?.join(', ') || 'None'}\n\nEvaluate the prompt and return a JSON object with this exact structure:\n{\n  \"score\": (0-5 number),\n  \"feedback\": \"Constructive feedback on the prompt quality\",\n  \"strengths\": [\"what they did well\"],\n  \"improvements\": [\"specific suggestions\"],\n  \"simulatedAIResponse\": \"What an AI would generate from this prompt\",\n  \"knowledgeUpdate\": {\n    \"masteredConcepts\": [\"concepts demonstrated mastery of\"],\n    \"identifiedGaps\": [\"gaps revealed by the prompt\"],\n    \"reasoning\": \"Brief explanation of knowledge assessment\"\n  }\n}`\n  }\n];\n\nreturn {\n  messages,\n  model: \"gpt-4o\",\n  temperature: 0.3,\n  max_tokens: 800,\n  response_format: { type: \"json_object\" },\n  // Pass through all data needed for processing\n  originalData: {\n    sessionId: $json.sessionId,\n    courseTopic: $json.courseTopic,\n    learnerProfile: $json.learnerProfile,\n    pendingPromptEvaluation: session.pendingPromptEvaluation,\n    currentConcept: session.currentConcept,\n    // IMPORTANT: Construct the responseData here\n    responseData: {\n      sessionId: $json.sessionId,\n      toolType: 'prompt_exercise',\n      conceptProgress: {\n        current: session.completedConcepts.length + 1,\n        total: session.remainingCoreConcepts.length + \n               session.completedConcepts.length + \n               session.insertedConcepts.length\n      },\n      toolData: {\n        task: session.pendingPromptEvaluation?.task || session.currentPromptExercise?.task || session.currentConcept?.promptTask,\n        context: session.currentPromptExercise?.context,\n        hints: session.currentPromptExercise?.hints || [],\n        conceptTitle: session.currentConcept?.title,\n        difficulty: session.currentPromptExercise?.difficulty || 'intermediate'\n      },\n      waitingForInput: false,\n      inputType: 'evaluation',\n      message: 'Evaluating your prompt...'\n    }\n  }\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -2200,
        650
      ],
      "id": "ecf45b14-bee3-48af-828b-2162c6836451",
      "name": "Generate Evaluate Prompt Excercise Prompt"
    },
    {
      "parameters": {
        "rules": {
          "values": [
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "id": "588c31ce-db6d-4b78-9dd0-bc639d4e4553",
                    "leftValue": "={{ $json.nextAction }}",
                    "rightValue": "grade_assessment",
                    "operator": {
                      "type": "string",
                      "operation": "equals",
                      "name": "filter.operator.equals"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "gradeAssessment"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "id": "60aca0f7-b783-4e53-a0b2-153342db2528",
                    "leftValue": "={{ $json.nextAction }}",
                    "rightValue": "generate_prompt_exercise",
                    "operator": {
                      "type": "string",
                      "operation": "equals",
                      "name": "filter.operator.equals"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "evaluatePrompt"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "id": "c41e007c-c9f8-4e01-9c3b-f5416eaa4575",
                    "leftValue": "={{ $json.nextAction }}",
                    "rightValue": "=concept_complete",
                    "operator": {
                      "type": "string",
                      "operation": "equals"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "completeConcept"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "leftValue": "={{ ['concept_card', 'assessment', 'prompt_exercise'].includes($json.nextAction) }}",
                    "rightValue": "={{ true }}",
                    "operator": {
                      "type": "boolean",
                      "operation": "true",
                      "singleValue": true
                    },
                    "id": "252d4b84-cc5a-482b-b966-c78ad46410f5"
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "coreToolRouter"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "id": "6131214d-57dc-4724-a4ee-daa86b8687ff",
                    "leftValue": "={{ $json.nextAction }}",
                    "rightValue": "=insert_concept",
                    "operator": {
                      "type": "string",
                      "operation": "equals"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "insertNewConcept"
            }
          ]
        },
        "options": {}
      },
      "id": "cfb2c81b-113a-4c72-9d91-009436e94d37",
      "name": "Adaptive Tool Router",
      "type": "n8n-nodes-base.switch",
      "typeVersion": 3.2,
      "position": [
        -2420,
        833
      ]
    },
    {
      "parameters": {
        "rules": {
          "values": [
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "leftValue": "={{ ['concept_card', 'insert_concept'].includes($json.nextAction) }}",
                    "rightValue": "concept_card",
                    "operator": {
                      "type": "boolean",
                      "operation": "true",
                      "singleValue": true
                    },
                    "id": "tool1"
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "conceptCard"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "leftValue": "={{ $json.nextAction }}",
                    "rightValue": "assessment",
                    "operator": {
                      "type": "string",
                      "operation": "equals"
                    },
                    "id": "tool2"
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "assessment"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "leftValue": "={{ $json.nextAction }}",
                    "rightValue": "prompt_exercise",
                    "operator": {
                      "type": "string",
                      "operation": "equals"
                    },
                    "id": "tool3"
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "promptExercise"
            }
          ]
        },
        "options": {}
      },
      "id": "ba3e15bd-373b-4386-8592-430322bf4df1",
      "name": "Core Tool Router",
      "type": "n8n-nodes-base.switch",
      "typeVersion": 3.2,
      "position": [
        -1540,
        1275
      ]
    },
    {
      "parameters": {
        "jsCode": "// Fix for Welcome Message Handler\n// Location: \"Welcome Message\" node\n\nconst sessionId = $json.sessionId;\nconst courseTopic = $json.courseTopic;\n\n// Get session from global\nconst session = $getWorkflowStaticData('global').sessions[sessionId];\n\n// UPDATE STATE MACHINE\nsession.stateMachine.previousState = session.stateMachine.currentState;\nsession.stateMachine.currentState = 'welcome';\nsession.stateMachine.stateHistory.push({\n  from: session.stateMachine.previousState,\n  to: 'welcome',\n  action: 'show_welcome',\n  timestamp: new Date().toISOString()\n});\n\n// Save updated state\n$getWorkflowStaticData('global').sessions[sessionId] = session;\n\nconst responseData = {\n  sessionId,\n  toolType: 'welcome',\n  toolData: {\n    title: `Welcome to: ${courseTopic}`,\n    message: 'This adaptive course will guide you through 10 core concepts with personalized instruction based on your progress.',\n    instructions: 'Click Next to begin with the first concept.'\n  },\n  waitingForInput: false,\n  nextAction: 'start_course'\n};\n\nreturn {\n  ...($json),\n  responseData\n};"
      },
      "id": "4cbaf678-cbcb-40c0-9b63-23718d42cbb4",
      "name": "Welcome Message Handler",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        0,
        200
      ]
    },
    {
      "parameters": {
        "jsCode": "// Fix for Complete Concept Handler\n// Location: \"Complete Concept\" node\n\nconst sessionId = $json.sessionId;\nconst currentConcept = $json.currentConcept || $json.sessionState?.currentConcept;\nconst session = $getWorkflowStaticData('global').sessions[sessionId];\n\nif (!currentConcept) {\n  console.log('Warning: No current concept to complete');\n}\n\n// UPDATE STATE MACHINE - Track concept completion\nsession.stateMachine.previousState = session.stateMachine.currentState;\nsession.stateMachine.currentState = 'concept_completing';\nsession.stateMachine.stateHistory.push({\n  from: session.stateMachine.previousState,\n  to: 'concept_completing',\n  action: 'complete_concept',\n  timestamp: new Date().toISOString(),\n  completedConceptId: currentConcept?.id,\n  completedConceptTitle: currentConcept?.title,\n  wasSkipped: session.skippedConcepts?.some(skip => skip.conceptId === currentConcept?.id),\n  finalScore: session.lastAssessmentScore\n});\n\n// Mark current concept as completed ONLY if we have one and it's not already completed\nif (currentConcept && !session.completedConcepts.includes(currentConcept.id)) {\n  session.completedConcepts.push(currentConcept.id);\n  \n  console.log(`Completed concept ${currentConcept.id}: ${currentConcept.title}`);\n  console.log(`Total completed: ${session.completedConcepts.length}`);\n  \n  // Note: We already removed it from remainingCoreConcepts when we started it\n  // So we don't need to remove it again here\n}\n\n// Check if this was a skipped concept\nconst wasSkipped = session.skippedConcepts?.some(\n  skip => skip.conceptId === currentConcept?.id\n);\n\n// Add metadata to completion\nif (!session.completionMetadata) session.completionMetadata = {};\nif (currentConcept) {\n  session.completionMetadata[currentConcept.id] = {\n    completedAt: new Date().toISOString(),\n    wasSkipped: wasSkipped,\n    toolsUsed: session.currentConceptTools,\n    assessmentScore: session.lastAssessmentScore,\n    completionType: wasSkipped ? 'skipped' : \n                    session.lastAssessmentScore >= 4 ? 'mastered' :\n                    session.lastAssessmentScore >= 3 ? 'adequate' : 'struggled'\n  };\n}\n\n// Reset for next concept - INCLUDING PROMPT EXERCISE CLEANUP\nsession.currentConcept = null;\nsession.currentConceptTools = [];\nsession.lastToolUsed = null;\nsession.lastAssessmentScore = null;\nsession.knowledgeGaps = [];\nsession.currentPromptExercise = null; // Clear the enhanced prompt exercise\nsession.currentExerciseFocus = null; // Clear any exercise focus from orchestrator\nsession.pendingAssessment = null;\nsession.pendingPromptEvaluation = null;\n\n// Save updated state\n$getWorkflowStaticData('global').sessions[sessionId] = session;\n\n// Prepare response to move to next concept\nconst responseData = {\n  sessionId,\n  toolType: 'transition',\n  conceptProgress: {\n    current: session.completedConcepts.length,\n    total: session.remainingCoreConcepts.length + \n           session.completedConcepts.length + \n           session.insertedConcepts.length\n  },\n  toolData: {\n    completedConcept: currentConcept?.title || 'Unknown',\n    message: 'Moving to next concept...'\n  },\n  waitingForInput: false,\n  nextAction: 'auto_continue'\n};\n\n// Debug info\nconsole.log(`Remaining concepts: ${session.remainingCoreConcepts.join(', ')}`);\nconsole.log(`State: ${session.stateMachine.currentState}`);\n\nreturn {\n  ...($json),\n  responseData,\n  moveToNext: true,\n  sessionState: session // Pass session state for debugging\n};"
      },
      "id": "abb2e55b-e968-4306-a18e-c641a70002a9",
      "name": "Complete Concept Handler",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -660,
        875
      ]
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// Fix for Insert Concept Handler\n// Location: \"Insert Concept\" node\n\nconst newConcept = JSON.parse($json.choices[0].message.content);\n\n// Get data from the pipeline (from Generate New Concept AI Call)\nconst sessionId = $('Generate New Concept Prompt').first().json.originalData.sessionId;\nconst originalData = $('Generate New Concept Prompt').first().json.originalData;\n\nconst orchestratorDecision = originalData.orchestratorDecision;\n\n// Add metadata to new concept\nnewConcept.id = `dynamic_${Date.now()}`;\nnewConcept.isCore = false;\nnewConcept.isDynamic = true;\n\n// Get session from global directly\nconst session = $getWorkflowStaticData('global').sessions[sessionId];\n\n// UPDATE STATE MACHINE - Track dynamic concept insertion\nsession.stateMachine.previousState = session.stateMachine.currentState;\nsession.stateMachine.currentState = 'dynamic_concept_inserted';\nsession.stateMachine.stateHistory.push({\n  from: session.stateMachine.previousState,\n  to: 'dynamic_concept_inserted',\n  action: 'insert_dynamic_concept',\n  timestamp: new Date().toISOString(),\n  dynamicConceptId: newConcept.id,\n  dynamicConceptTitle: newConcept.title,\n  targetedGap: orchestratorDecision.conceptNeeded.reason || session.knowledgeGaps[0],\n  previousConceptId: session.currentConcept?.id,\n  previousConceptTitle: session.currentConcept?.title\n});\n\n// Set targeted gaps from orchestrator decision\nconst targetGap = orchestratorDecision.conceptNeeded.reason || session.knowledgeGaps[0];\nnewConcept.targetedGaps = [targetGap];\nnewConcept.targetedGap = targetGap; // Keep both for compatibility\n\n// Increment the attempt counter for this gap\nif (targetGap) {\n  if (!session.gapAttempts) session.gapAttempts = {};\n  session.gapAttempts[targetGap] = (session.gapAttempts[targetGap] || 0) + 1;\n  newConcept.attemptNumber = session.gapAttempts[targetGap];\n}\n\n// IMPORTANT: Mark the struggling concept as completed so we don't return to it\nif (session.currentConcept && session.currentConcept.isCore) {\n  // Add the original concept to completed list\n  session.completedConcepts.push(session.currentConcept.id);\n  \n  // Remove it from remaining core concepts\n  session.remainingCoreConcepts = session.remainingCoreConcepts.filter(\n    id => id !== session.currentConcept.id\n  );\n}\n\n// Set the new concept as current\nsession.currentConcept = newConcept;\nsession.currentConceptTools = []; // Fresh start for the new concept\nsession.lastToolUsed = null;\n\n// Track the inserted dynamic concept\nsession.insertedConcepts.push(newConcept.id);\n\n// Clear previous assessment data since this is a new concept\nsession.lastAssessmentScore = null;\nsession.knowledgeGaps = []; // Clear the gaps\n\n// Save updated state back to global\n$getWorkflowStaticData('global').sessions[sessionId] = session;\n\n// Return with the updated current concept\nreturn {\n  ...originalData,\n  currentConcept: newConcept,\n  nextAction: 'concept_card',\n  newConceptInserted: true\n};"
      },
      "id": "878f49b5-1fd1-4f9c-b23f-21b9b335b670",
      "name": "Insert Concept Handler",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1760,
        1371
      ]
    }
  ],
  "pinData": {},
  "connections": {
    "Main Webhook": {
      "main": [
        [
          {
            "node": "Init Course Data",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Session State Manager": {
      "main": [
        [
          {
            "node": "Core Orchestrator",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Concept Card Handler": {
      "main": [
        [
          {
            "node": "Smart Reply Generator Prompt",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Assessment Handler": {
      "main": [
        [
          {
            "node": "Smart Reply Generator Prompt",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Process Grading": {
      "main": [
        [
          {
            "node": "Smart Reply Generator Prompt",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prompt Exercise Handler": {
      "main": [
        [
          {
            "node": "Generate Prompt Exercise Prompt",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Course Completion": {
      "main": [
        [
          {
            "node": "Merge Responses",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge Responses": {
      "main": [
        [
          {
            "node": "Limit Data",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Reset Session Webhook": {
      "main": [
        [
          {
            "node": "Reset Session",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Reset Session": {
      "main": [
        [
          {
            "node": "Reset Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Init Course Data": {
      "main": [
        [
          {
            "node": "Session State Manager",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Limit Data": {
      "main": [
        [
          {
            "node": "Webhook Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "When clicking 'Test workflow'": {
      "main": [
        [
          {
            "node": "Edit Fields",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Edit Fields": {
      "main": [
        [
          {
            "node": "Init Course Data",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Grade Assessment AI Call": {
      "main": [
        [
          {
            "node": "Process Grading",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Generate New Concept Prompt": {
      "main": [
        [
          {
            "node": "Generate New Concept AI Call",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Generate New Concept AI Call": {
      "main": [
        [
          {
            "node": "Insert Concept Handler",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Core Orchestrator": {
      "main": [
        [
          {
            "node": "Core Router",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Core Router": {
      "main": [
        [
          {
            "node": "Course Completion",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Welcome Message Handler",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Generate Assessment Grading Prompt",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Generate Evaluate Prompt Excercise Prompt",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Generate Adaptive Orchestrator Router Prompt",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Generate Adaptive Orchestrator Router Prompt",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Adaptive Orchestrator AI Call": {
      "main": [
        [
          {
            "node": "Process Adaptive Orchestrator Decision",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Process Adaptive Orchestrator Decision": {
      "main": [
        [
          {
            "node": "Adaptive Tool Router",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Smart Reply Generator Prompt": {
      "main": [
        [
          {
            "node": "Smart Reply Generator AI Call",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Smart Reply Generator AI Call": {
      "main": [
        [
          {
            "node": "Process Smart Replies",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Process Smart Replies": {
      "main": [
        [
          {
            "node": "Merge Responses",
            "type": "main",
            "index": 2
          }
        ]
      ]
    },
    "Generate Prompt Exercise Prompt": {
      "main": [
        [
          {
            "node": "Generate Prompt Exercise Generate AI Call",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Generate Prompt Exercise Generate AI Call": {
      "main": [
        [
          {
            "node": "Process Generated Prompt Exercise",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Generate Prompt Exercise Evaluation AI Call": {
      "main": [
        [
          {
            "node": "Process Prompt Evaluation",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Process Prompt Evaluation": {
      "main": [
        [
          {
            "node": "Smart Reply Generator Prompt",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Generate Assessment Grading Prompt": {
      "main": [
        [
          {
            "node": "Grade Assessment AI Call",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Process Generated Prompt Exercise": {
      "main": [
        [
          {
            "node": "Smart Reply Generator Prompt",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Generate Adaptive Orchestrator Router Prompt": {
      "main": [
        [
          {
            "node": "Adaptive Orchestrator AI Call",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Generate Evaluate Prompt Excercise Prompt": {
      "main": [
        [
          {
            "node": "Generate Prompt Exercise Evaluation AI Call",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Adaptive Tool Router": {
      "main": [
        [
          {
            "node": "Generate Assessment Grading Prompt",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Generate Evaluate Prompt Excercise Prompt",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Complete Concept Handler",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Core Tool Router",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Generate New Concept Prompt",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Core Tool Router": {
      "main": [
        [
          {
            "node": "Concept Card Handler",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Assessment Handler",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Prompt Exercise Handler",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Welcome Message Handler": {
      "main": [
        [
          {
            "node": "Merge Responses",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Complete Concept Handler": {
      "main": [
        [
          {
            "node": "Smart Reply Generator Prompt",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Insert Concept Handler": {
      "main": [
        [
          {
            "node": "Core Tool Router",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": true,
  "settings": {
    "executionOrder": "v1"
  },
  "versionId": "7efe48d6-70f1-42f1-83d5-bfa3d94d94bf",
  "meta": {
    "instanceId": "eea8bfa4918320bc469ce323a7b217b8209b639e450c67bc3e6a88bdf340b7de"
  },
  "id": "o4S651KbcozxQY97",
  "tags": []
}